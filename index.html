<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Daphne - Oramics Fluid Synth</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
            /* Touch screen optimizations */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            /* Prevent touch highlighting and scrolling */
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            /* Ensure canvas is touchable */
            pointer-events: auto;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #controls {
            position: absolute;
            top: 0;
            left: 20px;
            z-index: 100;
            transform: scale(0.75);
            transform-origin: top left;
            /* Ensure controls don't block canvas touches */
            pointer-events: none;
        }
        
        /* But allow interactions with control elements themselves */
        #controls * {
            pointer-events: auto;
        }
        
        #audioPanel {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border: none;
            border-radius: 0;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        
        #audioPanel.expanded {
            gap: 20px;
        }
        
        #toggleAudio {
            background: transparent;
            border: none;
            color: white;
            font-size: 13px;
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.2s;
            white-space: nowrap;
            padding: 0;
            margin: 0;
            line-height: 1;
            text-transform: uppercase;
        }
        
        #toggleAudio:hover {
            opacity: 0.7;
        }
        
        #colorPalette {
            display: flex;
            gap: 12px;
            align-items: center;
            opacity: 0;
            width: 0;
            overflow: visible;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 4px 0;
        }
        
        #colorPalette.visible {
            opacity: 1;
            width: auto;
        }
        
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            border: 0.75pt solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
        }
        
        .color-swatch.selected {
            border-color: white;
            border-width: 1.5pt;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        /* Glitch Effects Divider */
        .glitch-divider {
            width: 0.75pt;
            height: 32px;
            background: rgba(255, 255, 255, 0.3);
            margin: 0 8px;
            flex-shrink: 0;
        }
        
        .glitch-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 0.75pt solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            flex-shrink: 0;
        }
        
        .glitch-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .glitch-btn.active {
            background: rgba(0, 0, 0, 0.8);
            border-color: white;
            border-width: 1.5pt;
            color: white;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        /* Beat Buttons */
        .beat-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 0.75pt solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            flex-shrink: 0;
        }
        
        .beat-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .beat-btn.active {
            background: rgba(0, 0, 0, 0.8);
            border-color: white;
            border-width: 1.5pt;
            color: white;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .beat-btn.pulse {
            animation: beatPulse 0.2s ease-out;
        }
        
        @keyframes beatPulse {
            0% { transform: scale(1.1); }
            50% { transform: scale(1.3); box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 20px rgba(255, 255, 255, 0.9); }
            100% { transform: scale(1.1); }
        }
        
        /* Oramics Buttons */
        .oramics-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 0.75pt solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            flex-shrink: 0;
        }
        
        .oramics-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .oramics-btn.active {
            background: rgba(0, 0, 0, 0.8);
            border-color: white;
            border-width: 1.5pt;
            color: white;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        @keyframes oramicsPulse {
            0% { transform: scale(1.1) rotate(0deg); }
            50% { transform: scale(1.15) rotate(180deg); }
            100% { transform: scale(1.1) rotate(360deg); }
        }
        
        /* ===== MOBILE RESPONSIVE LAYOUT ===== */
        @media (max-width: 768px) {
            /* Reposition controls to left edge */
            #controls {
                position: fixed;
                top: 0;
                left: 0;
                transform: none;
                z-index: 100;
                height: 100vh;
                display: flex;
                align-items: flex-start;
            }
            
            /* Audio panel - vertical layout */
            #audioPanel {
                flex-direction: column;
                align-items: flex-start;
                padding: 0;
                gap: 0;
                background: transparent;
                backdrop-filter: none;
                box-shadow: none;
                height: 100vh;
            }
            
            #audioPanel.expanded {
                gap: 0;
            }
            
            /* Sound On button - rotated 90° on left edge, 20% smaller */
            #toggleAudio {
                writing-mode: vertical-rl;
                text-orientation: mixed;
                transform: rotate(180deg);
                padding: 16px 10px; /* 20% smaller padding */
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                border-radius: 0;
                font-size: 9px; /* 20% smaller from 11px */
                letter-spacing: 1.6px; /* 20% smaller from 2px */
                height: auto;
                width: auto;
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.5);
                /* Touch friendly */
                -webkit-tap-highlight-color: transparent;
            }
            
            /* Palette container - vertical stacking */
            #colorPalette {
                flex-direction: column;
                gap: 8px;
                padding: 12px 8px;
                width: auto;
                max-height: calc(100vh - 100px);
                overflow-y: auto;
                overflow-x: visible;
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.5);
                /* Smooth touch scrolling */
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                touch-action: pan-y; /* Allow vertical scrolling only */
            }
            
            #colorPalette.visible {
                opacity: 1;
                width: auto;
            }
            
            /* All buttons - 20% smaller on mobile */
            .color-swatch,
            .glitch-btn,
            .beat-btn,
            .oramics-btn {
                width: 26px;
                height: 26px;
                font-size: 14px;
            }
            
            /* Dividers - horizontal in vertical layout */
            .glitch-divider {
                width: 26px;
                height: 0.75pt;
                margin: 4px 0;
            }
            
            /* Two-column layout if palette is too long */
            @supports (display: grid) {
                #colorPalette {
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 8px;
                    padding: 12px;
                    justify-items: center;
                }
                
                /* Dividers span full width in grid */
                .glitch-divider {
                    grid-column: 1 / -1;
                    width: 100%;
                    height: 0.75pt;
                    margin: 4px 0;
                }
            }
        }
        
        /* Extra small screens - single column */
        @media (max-width: 480px) {
            #colorPalette {
                grid-template-columns: 1fr !important;
            }
            
            .glitch-divider {
                grid-column: 1 !important;
            }
        }
        
        /* Landscape mobile - different approach */
        @media (max-width: 896px) and (orientation: landscape) {
            #colorPalette {
                max-height: calc(100vh - 60px);
                grid-template-columns: 1fr 1fr;
            }
            
            .color-swatch,
            .glitch-btn,
            .beat-btn,
            .oramics-btn {
                width: 26px;
                height: 26px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <div id="audioPanel">
            <button id="toggleAudio">Sound On</button>
            <div id="colorPalette"></div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl', {
            alpha: false,
            depth: false,
            stencil: false,
            antialias: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL not supported');
        }

        const floatExt = gl.getExtension('OES_texture_float');
        const floatLinearExt = gl.getExtension('OES_texture_float_linear');

        let simWidth = 128;
        let simHeight = 128;

        function resize() {
            const dpr = Math.min(window.devicePixelRatio, 2);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
        }
        resize();
        window.addEventListener('resize', resize);

        // COLOR VOICE SYSTEM with persistence
        /*
         * COLOR-SPECIFIC SCALES:
         * Each color now uses a different musical scale for variety!
         * This means different colors will play different sets of notes.
         */
        const colorVoices = [
            {
                color: { r: 0.4, g: 0.4, b: 0.4 },
                hex: '#666666',
                persistence: 0.8,
                diffusion: 0.3,
                scale: 'pentatonic',  // Grey = Pentatonic (safe, balanced)
                sound: {
                    waveform: 'sine',
                    baseFreqMultiplier: 0.5,
                    harmonics: 1,
                    attack: 0.2,
                    filterType: 'lowpass',
                    filterFreq: 400,
                    filterQ: 1,
                    reverbMix: 0.8,
                    detune: 0
                }
            },
            {
                color: { r: 0.7, g: 0.4, b: 0.3 },
                hex: '#B36A49',
                persistence: 0.7,
                diffusion: 0.4,
                scale: 'blues',  // Brown = Blues (earthy, soulful, grounded)
                sound: {
                    waveform: 'triangle',
                    baseFreqMultiplier: 0.5,
                    harmonics: 3,
                    attack: 0.15,
                    filterType: 'lowpass',
                    filterFreq: 400,
                    filterQ: 2,
                    reverbMix: 0.4,
                    detune: 8,
                    // EARTHY TEXTURE - subtle grit and crackle layered on top
                    useHeavyDistortion: true,
                    distortionDrive: 2.5,  // Subtle warmth and grit
                    useBitCrusher: false,  // Too harsh, removed
                    useCrackle: true,
                    crackleRate: 18,  // Moderate crackles
                    crackleIntensity: 0.4,  // Quiet, background texture
                    useSubBass: true,
                    subBassFreq: 0.25,  // Low rumble
                    useRumble: true,
                    rumbleVolume: 0.25,  // Subtle rumble layer
                    heavyNoise: true,
                    noiseRatio: 0.6  // Present but not overwhelming
                }
            },
            {
                color: { r: 0.3, g: 0.4, b: 0.9 },
                hex: '#4D5DE8',
                persistence: 1.0,
                diffusion: 0.25,
                scale: 'minor',  // Blue = Minor (emotional, deep, melancholic)
                sound: {
                    waveform: 'sine',
                    baseFreqMultiplier: 0.5,
                    harmonics: 3,
                    attack: 0.3,
                    filterType: 'lowpass',
                    filterFreq: 500,
                    filterQ: 2,
                    reverbMix: 0.85,
                    detune: 12,
                    useModulation: true,
                    modulationRate: 0.3,
                    modulationDepth: 15
                }
            },
            {
                color: { r: 0.85, g: 0.9, b: 0.3 },
                hex: '#D9E64D',
                persistence: 0.4,
                diffusion: 0.6,
                scale: 'major',  // Yellow = Major (bright, happy, uplifting)
                sound: {
                    waveform: 'sawtooth',
                    baseFreqMultiplier: 6.0,
                    harmonics: 10,
                    attack: 0.02,
                    filterType: 'highpass',
                    filterFreq: 2500,
                    filterQ: 4,
                    reverbMix: 0.3,
                    detune: 40
                }
            },
            {
                color: { r: 0.2, g: 0.8, b: 0.4 },
                hex: '#33CC66',
                persistence: 0.8,
                diffusion: 0.35,
                scale: 'pentatonic',  // Green = Pentatonic (natural, balanced, bamboo-like)
                sound: {
                    waveform: 'triangle',
                    baseFreqMultiplier: 2.5,
                    harmonics: 3,
                    attack: 0.001,  // Instant like bamboo strike
                    filterType: 'bandpass',
                    filterFreq: 1800,
                    filterQ: 6,
                    reverbMix: 0.95,  // Huge reverb for forest atmosphere
                    detune: 3,
                    // BAMBOO WIND CHIMES - hollow resonant tubes with multiple pitches
                    useBamboo: true,
                    bambooTubes: [1.0, 1.33, 1.5, 2.0, 2.67, 3.0, 4.0],  // Pentatonic-ish tuning
                    bambooDecay: 0.4,  // Long resonance
                    bambooVolume: 0.9,
                    useHollowResonance: true,  // Hollow tube effect
                    resonanceFreq: 0.75,  // Sub-frequency for hollow sound
                    useWindNoise: true,  // Air rushing through bamboo
                    windIntensity: 0.4,
                    useMetallicShimmer: true,  // High metallic overtones
                    shimmerCount: 8
                }
            },
            {
                color: { r: 0.95, g: 0.6, b: 0.7 },
                hex: '#F299B3',
                persistence: 1.0,
                diffusion: 0.3,
                scale: 'harmonicMinor',  // Pink = Harmonic Minor (exotic, crystalline, mysterious)
                sound: {
                    waveform: 'sine',
                    baseFreqMultiplier: 4.0,  // Very high pitch
                    harmonics: 1,
                    attack: 0.0005,  // Nearly instant like ice cracking
                    filterType: 'highpass',
                    filterFreq: 3000,  // Only high frequencies
                    filterQ: 2,
                    reverbMix: 0.98,  // Maximum reverb for frozen space
                    detune: 0,
                    // ICE CRYSTALS - brittle, crackling, frozen glass texture
                    useIceCrackle: true,
                    iceCrackleCount: 25,  // Many small cracks
                    crackleIntensity: 0.9,
                    crackleSpeed: 0.02,  // Very fast pops
                    useFrozenResonance: true,  // High pitched resonance
                    frozenPitches: [8.0, 10.0, 12.0, 15.0, 18.0],  // Very high harmonics
                    useGlassShatter: true,  // Scattered glass sounds
                    shatterDensity: 12,
                    useHighShimmer: true,  // Ultra-high frequency sparkle
                    shimmerFreq: 12.0
                }
            },
            {
                color: { r: 1.0, g: 0.4, b: 0.35 },
                hex: '#FF6659',
                persistence: 0.5,
                diffusion: 0.5,
                scale: 'chromatic',  // Red = Chromatic (all notes, industrial, chaotic)
                sound: {
                    waveform: 'sawtooth',
                    baseFreqMultiplier: 0.5,  // Low, heavy frequency
                    harmonics: 12,  // Many harsh harmonics
                    attack: 0.005,
                    filterType: 'lowpass',
                    filterFreq: 600,
                    filterQ: 4,
                    reverbMix: 0.4,
                    detune: 40,
                    // INDUSTRIAL MACHINERY - grinding metal, mechanical hits, heavy distortion
                    useMetalGrind: true,
                    grindIntensity: 1.2,
                    grindModulation: 8.0,  // Fast modulation for grinding texture
                    useHeavyDistortion: true,
                    distortionDrive: 6.0,  // Heavy overdrive
                    useMetalHits: true,  // Percussive metal impacts
                    metalHitCount: 15,
                    metalHitVolume: 0.8,
                    useGrindNoise: true,  // Harsh noise layer
                    grindNoiseRatio: 1.5,
                    useLowRumble: true,  // Deep machinery rumble
                    rumbleFreq: 0.3
                }
            }
        ];

        let selectedColorIndex = -1;
        let currentDynamicColor = { r: 0.56, g: 0.57, b: 0.62 };
        let currentDiffusion = 0.3;

        // ===== GLITCH EFFECTS SYSTEM =====
        const glitchEffects = {
            bitCrush: { active: false, name: 'Bit Crush', icon: '◼' },
            corrupt: { active: false, name: 'Corrupt', icon: '◆' },
            feedback: { active: false, name: 'Feedback', icon: '↻' },
            rgbSplit: { active: false, name: 'RGB Split', icon: '▣' },
            freeze: { active: false, name: 'Freeze', icon: '❄' }
        };
        
        let glitchState = {
            bitCrushDepth: 4,
            corruptionRate: 0.05,
            feedbackAmount: 0.3,
            rgbSplitAmount: 0.01,
            freezeFrame: null,
            pixelSize: 32,  // EXTREME: Much larger pixels
            prismLayers: 5
        };

        // ===== MUSICAL QUANTIZATION SYSTEM =====
        
        /*
         * WHAT IS QUANTIZATION?
         * --------------------
         * Quantization "snaps" frequencies to real musical notes, like snapping to a grid.
         * Instead of playing 442Hz (slightly out of tune), it rounds to 440Hz (perfect A note).
         * 
         * WHY A440 STANDARD?
         * - A440 means the note "A above middle C" vibrates at exactly 440 times per second
         * - This is the universal tuning standard used by orchestras and musicians worldwide
         * - All other notes are calculated relative to this anchor point
         * 
         * EQUAL TEMPERAMENT:
         * - Each half-step (semitone) multiplies frequency by 2^(1/12) ≈ 1.059463
         * - There are 12 semitones in an octave
         * - Doubling frequency = going up one octave (A220 → A440 → A880)
         */
        
        // Note names for reference (C0 = MIDI note 12, A4 = MIDI note 69 = 440Hz)
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Musical scales as intervals from root note (in semitones)
        const SCALES = {
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],  // All 12 notes
            major: [0, 2, 4, 5, 7, 9, 11],  // Happy, bright (Do-Re-Mi-Fa-Sol-La-Ti)
            minor: [0, 2, 3, 5, 7, 8, 10],  // Sad, emotional
            pentatonic: [0, 2, 4, 7, 9],    // Can't play a wrong note! (black keys on piano)
            blues: [0, 3, 5, 6, 7, 10],     // Bluesy, soulful
            wholeTone: [0, 2, 4, 6, 8, 10], // Dreamy, floating, no tonal center (used in impressionist music)
            harmonicMinor: [0, 2, 3, 5, 7, 8, 11]  // Exotic, mysterious, crystalline (Middle Eastern flavor)
        };
        
        // Current musical settings
        let musicalSettings = {
            rootNote: 60,        // Middle C (MIDI note 60 = 261.63Hz)
            scale: 'pentatonic', // Start with pentatonic - easiest to sound good!
            octaveRange: 3       // How many octaves we can span
        };
        
        /**
         * Convert MIDI note number to frequency in Hz
         * Formula: freq = 440 * 2^((midiNote - 69) / 12)
         * Where 69 is the MIDI number for A440
         */
        function midiToFreq(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
        
        /**
         * Convert frequency to nearest MIDI note number
         */
        function freqToMidi(freq) {
            return Math.round(69 + 12 * Math.log2(freq / 440));
        }
        
        /**
         * QUANTIZE FREQUENCY TO MUSICAL NOTE
         * This is the core function that makes frequencies musical!
         * 
         * @param {number} rawFreq - Any frequency (could be off-tune)
         * @param {string} scaleName - Which scale to use (pentatonic, major, etc.)
         * @param {number} rootNote - Root note of the scale (MIDI number)
         * @returns {number} - Quantized frequency that fits the scale
         */
        function quantizeToScale(rawFreq, scaleName = 'pentatonic', rootNote = 60) {
            // 1. Convert the raw frequency to a MIDI note number
            const rawMidi = freqToMidi(rawFreq);
            
            // 2. Get the scale intervals
            const scale = SCALES[scaleName] || SCALES.pentatonic;
            
            // 3. Find which octave we're in relative to the root
            const noteInOctave = ((rawMidi - rootNote) % 12 + 12) % 12;
            const octaveOffset = Math.floor((rawMidi - rootNote) / 12);
            
            // 4. Find the closest note in the scale
            let closestInterval = scale[0];
            let minDistance = Math.abs(noteInOctave - closestInterval);
            
            for (let interval of scale) {
                const distance = Math.abs(noteInOctave - interval);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestInterval = interval;
                }
            }
            
            // 5. Calculate the final MIDI note (in the correct octave)
            const quantizedMidi = rootNote + octaveOffset * 12 + closestInterval;
            
            // 6. Convert back to frequency
            return midiToFreq(quantizedMidi);
        }

        // ===== MUSICAL RHYTHM SYSTEM =====
        
        /*
         * MUSICAL TIME EXPLAINED:
         * ----------------------
         * Music is organized into beats and subdivisions:
         * 
         * TEMPO (BPM) = Beats Per Minute
         * - 120 BPM means 120 quarter notes per minute = 2 per second
         * - Standard dance music: 120-130 BPM
         * - Standard hip-hop: 80-100 BPM
         * 
         * NOTE DIVISIONS:
         * - Whole note = 4 beats (very slow)
         * - Half note = 2 beats
         * - Quarter note = 1 beat (the "pulse" of the song)
         * - Eighth note = 0.5 beats (twice as fast)
         * - Sixteenth note = 0.25 beats (four times as fast)
         * 
         * TIME SIGNATURE:
         * - 4/4 means: 4 beats per measure, quarter note gets the beat
         * - Most common in Western music
         */
        
        // Master musical clock
        let musicalClock = {
            bpm: 120,              // Master tempo (beats per minute)
            isPlaying: false,
            startTime: 0,          // When the clock started
            currentBeat: 0,        // Which beat we're on
            beatsPerBar: 4,        // Time signature (4/4 time)
            audioContext: null
        };
        
        /**
         * Calculate interval in milliseconds for a given note division
         * @param {number} division - 1 = quarter note, 0.5 = eighth, 0.25 = sixteenth, 2 = half
         */
        function getMusicalInterval(division) {
            const quarterNoteMs = (60 / musicalClock.bpm) * 1000;
            return quarterNoteMs * division;
        }
        
        // Beat system with MUSICAL subdivisions instead of random BPMs
        const beatEffects = {
            // Kick = Quarter notes (on the beat: 1, 2, 3, 4)
            kick: { 
                active: false, 
                name: 'Kick', 
                icon: '●', 
                division: 1.0,     // Plays every quarter note
                interval: null,
                description: 'Quarter notes - on every beat'
            },
            // Hi-hat = Eighth notes (twice as fast: 1-and-2-and-3-and-4-and)
            hihat: { 
                active: false, 
                name: 'Hi-Hat', 
                icon: '×', 
                division: 0.5,     // Plays every eighth note
                interval: null,
                description: 'Eighth notes - double time'
            },
            // Snare = Half notes (on beats 2 and 4 - the "backbeat")
            snare: { 
                active: false, 
                name: 'Snare', 
                icon: '▬', 
                division: 2.0,     // Plays every half note
                interval: null,
                skipFirstBeat: true, // Skip beat 1, play on beat 3 for that backbeat feel
                description: 'Backbeat - on beats 2 & 4'
            },
            // Pulse = Whole notes (every 4 beats - very slow)
            pulse: { 
                active: false, 
                name: 'Pulse', 
                icon: '◉', 
                division: 4.0,     // Plays every whole note (once per bar)
                interval: null,
                description: 'Whole notes - once per bar'
            },
            // Fast Shaker = Sixteenth notes (4x faster than kick - very quick, light)
            shaker: { 
                active: false, 
                name: 'Shaker', 
                icon: '⋮', 
                division: 0.25,    // Plays every sixteenth note (4x per beat)
                interval: null,
                description: 'Sixteenth notes - fast ambient texture'
            },
            // Slow Tom = Half notes (every 2 beats - deep, mellow)
            tom: { 
                active: false, 
                name: 'Tom', 
                icon: '○', 
                division: 2.0,     // Plays every half note
                interval: null,
                description: 'Half notes - slow, deep toms'
            },
            // Ambient Click = Dotted quarter notes (syncopated rhythm - subtle)
            click: { 
                active: false, 
                name: 'Click', 
                icon: '·', 
                division: 1.5,     // Plays every dotted quarter (1.5 beats)
                interval: null,
                description: 'Dotted quarters - subtle syncopation'
            }
        };

        // ===== ORAMICS EFFECTS SYSTEM (Daphne Oram-inspired) =====
        /*
         * Inspired by Daphne Oram's pioneering Oramics technique
         * where visual gestures directly control sound synthesis
         */
        const oramicsEffects = {
            paintedEnvelope: {
                active: false,
                name: 'Painted Envelope',
                icon: '⟲', // Swirl icon
                description: 'Gesture shape controls sound evolution'
            },
            drawnWaveforms: {
                active: false,
                name: 'Drawn Waveforms',
                icon: '∿', // Sine wave icon
                description: 'Visual patterns become sound waves (Oramics)'
            },
            patternSequencer: {
                active: false,
                name: 'Pattern Sequencer',
                icon: '⊞', // Grid icon
                description: 'Paint zones trigger notes as fluid flows through'
            },
            gestureDrones: {
                active: false,
                name: 'Gesture Drones',
                icon: '〰', // Wave/drone icon
                description: 'Sustained painting creates evolving ambient layers'
            },
            textureMode: {
                active: false,
                name: 'Texture Mode',
                icon: '▦', // Texture/pattern icon
                description: 'Non-pitched textures: noise, percussion, granular, industrial'
            },
            textureMode2: {
                active: false,
                name: 'Texture Mode 2',
                icon: '▧', // Alternate texture icon
                description: 'Electronic textures: FM bells, ring mod, bit-crush, vocoder'
            },
            arpeggiator: {
                active: false,
                name: 'Arpeggiator',
                icon: '⟨⟩', // Sequence icon
                description: 'Sequenced note patterns that evolve with your painting'
            },
            stutter: {
                active: false,
                name: 'Stutter',
                icon: '⧈', // Glitch/repeat icon
                description: 'Glitchy repetitions and rhythmic freezes'
            },
        polyrhythm: {
            active: false,
            name: 'Polyrhythm',
            icon: '◈', // Multiple rhythm icon
            description: 'Multiple overlapping rhythm layers'
        }
        };

        function initColorPalette() {
            const palette = document.getElementById('colorPalette');
            colorVoices.forEach((voice, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.background = voice.hex;
                swatch.title = `Color voice ${index + 1}`;
                swatch.addEventListener('click', () => selectColor(index));
                palette.appendChild(swatch);
            });
        }

        function selectColor(index) {
            selectedColorIndex = index;
            document.querySelectorAll('.color-swatch').forEach((swatch, i) => {
                swatch.classList.toggle('selected', i === index);
            });
            
            const voice = colorVoices[index];
            currentDynamicColor = voice.color;
            currentDiffusion = voice.diffusion;
        }

        // ===== GLITCH FUNCTIONS =====
        
        function initGlitchPanel() {
            const palette = document.getElementById('colorPalette');
            
            // Add divider
            const divider = document.createElement('div');
            divider.className = 'glitch-divider';
            palette.appendChild(divider);
            
            // Add glitch buttons
            Object.keys(glitchEffects).forEach((key) => {
                const effect = glitchEffects[key];
                const btn = document.createElement('button');
                btn.className = 'glitch-btn';
                btn.innerHTML = effect.icon;
                btn.dataset.glitch = key;
                btn.title = effect.name;
                btn.addEventListener('click', () => toggleGlitch(key, btn));
                palette.appendChild(btn);
            });
        }
        
        function toggleGlitch(key, btn) {
            glitchEffects[key].active = !glitchEffects[key].active;
            btn.classList.toggle('active', glitchEffects[key].active);
        }
        
        // ===== BEAT FUNCTIONS =====
        
        function initBeatPanel() {
            const palette = document.getElementById('colorPalette');
            
            // Add divider
            const divider = document.createElement('div');
            divider.className = 'glitch-divider';
            palette.appendChild(divider);
            
            // Add beat buttons with MUSICAL descriptions
            Object.keys(beatEffects).forEach((key) => {
                const effect = beatEffects[key];
                const btn = document.createElement('button');
                btn.className = 'beat-btn';
                btn.innerHTML = effect.icon;
                btn.dataset.beat = key;
                // Show musical timing instead of arbitrary BPM
                btn.title = `${effect.name} - ${effect.description}`;
                btn.addEventListener('click', () => toggleBeat(key, btn));
                palette.appendChild(btn);
            });
        }
        
        function toggleBeat(key, btn) {
            const beat = beatEffects[key];
            beat.active = !beat.active;
            btn.classList.toggle('active', beat.active);
            
            if (beat.active) {
                startBeat(key, btn);
            } else {
                stopBeat(key);
            }
        }
        
        function startBeat(key, btn) {
            const beat = beatEffects[key];
            
            /*
             * MUSICAL TIMING:
             * Instead of using arbitrary BPM values, we calculate the interval
             * based on musical note divisions (quarter, eighth, etc.)
             * 
             * For example:
             * - If BPM = 120, one quarter note = 500ms
             * - Eighth note (division 0.5) = 250ms
             * - Half note (division 2.0) = 1000ms
             * 
             * This ensures all beats are musically related!
             */
            const intervalMs = getMusicalInterval(beat.division);
            
            // Trigger immediately
            triggerBeat(key, btn);
            
            // Set up interval using musical timing
            beat.interval = setInterval(() => {
                triggerBeat(key, btn);
            }, intervalMs);
        }
        
        function stopBeat(key) {
            const beat = beatEffects[key];
            if (beat.interval) {
                clearInterval(beat.interval);
                beat.interval = null;
            }
        }
        
        function triggerBeat(key, btn) {
            // Visual pulse on button
            btn.classList.remove('pulse');
            setTimeout(() => btn.classList.add('pulse'), 10);
            
            // Create visual splat
            createBeatSplat(key);
            
            // Create audio
            if (audioEnabled && audioContext) {
                createBeatSound(key);
            }
        }
        
        // ===== ORAMICS FUNCTIONS =====
        
        function initOramicsPanel() {
            const palette = document.getElementById('colorPalette');
            
            // Add divider
            const divider = document.createElement('div');
            divider.className = 'glitch-divider';
            palette.appendChild(divider);
            
            // Add Oramics buttons
            Object.keys(oramicsEffects).forEach((key) => {
                const effect = oramicsEffects[key];
                const btn = document.createElement('button');
                btn.className = 'oramics-btn';
                btn.innerHTML = effect.icon;
                btn.dataset.oramics = key;
                btn.title = `${effect.name} - ${effect.description}`;
                btn.addEventListener('click', () => toggleOramics(key, btn));
                palette.appendChild(btn);
            });
        }
        
        function toggleOramics(key, btn) {
            // If activating a texture mode, deactivate the other texture modes
            if ((key === 'textureMode' || key === 'textureMode2') && !oramicsEffects[key].active) {
                // Turn off other texture modes
                if (key === 'textureMode' && oramicsEffects.textureMode2.active) {
                    oramicsEffects.textureMode2.active = false;
                    document.querySelector(`[data-oramics="textureMode2"]`).classList.remove('active');
                } else if (key === 'textureMode2' && oramicsEffects.textureMode.active) {
                    oramicsEffects.textureMode.active = false;
                    document.querySelector(`[data-oramics="textureMode"]`).classList.remove('active');
                }
            }
            
            oramicsEffects[key].active = !oramicsEffects[key].active;
            btn.classList.toggle('active', oramicsEffects[key].active);
        }
        
        function createBeatSplat(key) {
            if (!gl || !splatProgram) return;
            
            const positions = {
                kick: { x: 0.5, y: 0.2 },    // Bottom center
                hihat: { x: 0.8, y: 0.8 },   // Top right
                snare: { x: 0.5, y: 0.5 },   // Center
                pulse: { x: 0.2, y: 0.8 },   // Top left
                shaker: { x: 0.8, y: 0.5 },  // Right center (fast shaker)
                tom: { x: 0.2, y: 0.3 },     // Bottom left (slow tom)
                click: { x: 0.65, y: 0.7 }   // Top right-center (ambient click)
            };
            
            const pos = positions[key];
            const splatX = pos.x + (Math.random() - 0.5) * 0.1;
            const splatY = pos.y + (Math.random() - 0.5) * 0.1;
            
            // Velocity splat
            gl.useProgram(splatProgram);
            const posLoc = gl.getAttribLocation(splatProgram, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            
            bindFramebuffer(velocity.write);
            gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
            gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
            gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), splatX, splatY);
            
            const angle = Math.random() * Math.PI * 2;
            const force = key === 'kick' ? 20.0 : 
                         key === 'snare' ? 15.0 : 
                         key === 'hihat' ? 8.0 : 
                         key === 'tom' ? 12.0 :      // Medium force for tom
                         key === 'shaker' ? 4.0 :    // Very light for fast shaker
                         key === 'click' ? 5.0 :     // Light for ambient click
                         12.0;                        // Default for pulse
            
            gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'),
                Math.cos(angle) * force,
                Math.sin(angle) * force,
                0.0
            );
            gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'),
                key === 'kick' ? 0.015 :    // Large kick
                key === 'pulse' ? 0.012 :   // Medium pulse
                key === 'tom' ? 0.010 :     // Medium tom
                key === 'shaker' ? 0.005 :  // Tiny shaker
                key === 'click' ? 0.006 :   // Small click
                0.008                        // Default (hihat, snare)
            );
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            velocity.swap();
        }
        
        function createBeatSound(key) {
            const now = audioContext.currentTime;
            
            /*
             * MUSICAL BEAT SOUNDS:
             * Instead of random frequencies, beats now use musical notes
             * based on the current scale and root note.
             * This makes the rhythm section harmonize with the melodies!
             */
            
            if (key === 'kick') {
                /*
                 * KICK DRUM:
                 * - Uses the ROOT NOTE as its pitch (the foundation)
                 * - Drops down one octave for deep bass (-12 semitones)
                 * - Pitch slides down for that classic "thump" sound
                 */
                const rootFreq = midiToFreq(musicalSettings.rootNote - 12);  // One octave below root
                
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = rootFreq;
                osc.frequency.exponentialRampToValueAtTime(rootFreq * 0.5, now + 0.1);  // Slide down
                
                const env = audioContext.createGain();
                env.gain.value = 0.4;
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                osc.connect(env);
                env.connect(masterGain);
                osc.start(now);
                osc.stop(now + 0.3);
                
            } else if (key === 'hihat') {
                /*
                 * HI-HAT:
                 * - Pure noise (not pitched)
                 * - High frequency for crisp, bright sound
                 * - Very short duration for tight rhythm
                 */
                const bufferSize = audioContext.sampleRate * 0.05;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 8000;
                
                const env = audioContext.createGain();
                env.gain.value = 0.15;
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                
                noise.connect(filter);
                filter.connect(env);
                env.connect(masterGain);
                noise.start(now);
                
            } else if (key === 'snare') {
                /*
                 * SNARE:
                 * - Uses the FIFTH note of the scale (7 semitones up)
                 * - The "fifth" is super stable and supportive in music
                 * - Combines tone + noise for that classic snare "crack"
                 */
                const fifthFreq = midiToFreq(musicalSettings.rootNote + 7);  // Perfect fifth
                
                const osc = audioContext.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = fifthFreq;
                
                const oscEnv = audioContext.createGain();
                oscEnv.gain.value = 0.2;
                oscEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                
                // Noise component for "crack"
                const bufferSize = audioContext.sampleRate * 0.1;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const noiseEnv = audioContext.createGain();
                noiseEnv.gain.value = 0.3;
                noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                osc.connect(oscEnv);
                oscEnv.connect(masterGain);
                noise.connect(noiseEnv);
                noiseEnv.connect(masterGain);
                
                osc.start(now);
                osc.stop(now + 0.15);
                noise.start(now);
                
            } else if (key === 'pulse') {
                /*
                 * PULSE:
                 * - Uses the ROOT NOTE at its natural octave
                 * - Soft, sustained tone that grounds the harmony
                 * - With reverb for spacious, ambient feel
                 */
                const rootFreq = midiToFreq(musicalSettings.rootNote);
                
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = rootFreq;
                
                const env = audioContext.createGain();
                env.gain.value = 0.15;  // Increased volume so it's audible
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.4);  // Longer duration
                
                osc.connect(env);
                // Connect to both convolver (for reverb) AND master (for direct sound)
                env.connect(convolver);
                env.connect(masterGain);
                osc.start(now);
                osc.stop(now + 0.4);
                
            } else if (key === 'shaker') {
                /*
                 * FAST SHAKER:
                 * - Very short, filtered noise for fast ambient texture
                 * - High frequency, STRONGER and more audible
                 * - Adds rhythmic shimmer that you can actually hear!
                 */
                const bufferSize = audioContext.sampleRate * 0.03;  // Slightly longer (30ms)
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.7;  // Much louder noise
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';  // Changed to highpass for more presence
                filter.frequency.value = 4000;  // Slightly lower for more body
                filter.Q.value = 1;
                
                const env = audioContext.createGain();
                env.gain.value = 0.25;  // Much louder! 3x stronger
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
                
                noise.connect(filter);
                filter.connect(env);
                env.connect(masterGain);  // Direct to master for clarity
                env.connect(convolver);   // Also with reverb
                noise.start(now);
                
            } else if (key === 'tom') {
                /*
                 * SLOW TOM:
                 * - Deep, mellow tom using the third note of the scale
                 * - Low frequency for warmth, not too aggressive
                 * - Ambient, subtle, with slow timing
                 */
                const thirdFreq = midiToFreq(musicalSettings.rootNote + 4 - 12);  // Third note, one octave down
                
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = thirdFreq;
                osc.frequency.exponentialRampToValueAtTime(thirdFreq * 0.7, now + 0.2);  // Pitch slide down
                
                const env = audioContext.createGain();
                env.gain.value = 0.12;  // Soft, ambient volume
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                
                osc.connect(env);
                env.connect(convolver);  // With reverb for mellowness
                env.connect(masterGain);
                osc.start(now);
                osc.stop(now + 0.4);
                
            } else if (key === 'click') {
                /*
                 * AMBIENT CLICK:
                 * - Very short, high-pitched click using the second scale degree
                 * - Creates subtle syncopation with dotted quarter timing
                 * - Adds interest without dominating the rhythm
                 */
                const secondFreq = midiToFreq(musicalSettings.rootNote + 2 + 12);  // Second note, one octave up
                
                const osc = audioContext.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = secondFreq;
                
                const env = audioContext.createGain();
                env.gain.value = 0.06;  // Very quiet, just a subtle accent
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
                
                osc.connect(env);
                env.connect(convolver);  // With reverb for ambient quality
                osc.start(now);
                osc.stop(now + 0.03);
            }
        }
        
        // Apply audio glitches to the color voice audio nodes
        function applyAudioGlitches(audioNodes) {
            if (!audioContext || !audioNodes) return audioNodes;
            
            let output = audioNodes.output;
            const cursorVelocity = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
            const now = audioContext.currentTime;
            
            /*
             * ═══════════════════════════════════════════════════════════
             * BIT CRUSH (◼) - DIGITAL DEGRADATION TEXTURE
             * ═══════════════════════════════════════════════════════════
             * Visual: Pixelated, blocky, quantized
             * Sound: Sample rate reduction, digital aliasing, steppy texture
             */
            if (glitchEffects.bitCrush.active) {
                // 1. BIT DEPTH REDUCTION (amplitude quantization)
                const bitCrusher = audioContext.createWaveShaper();
                const curve = new Float32Array(256);
                // Cursor velocity makes it MORE crushed (faster = more lo-fi)
                const dynamicDepth = Math.max(1, glitchState.bitCrushDepth - cursorVelocity * 30);
                const step = Math.pow(2, dynamicDepth);
                for (let i = 0; i < 256; i++) {
                    const x = (i / 128) - 1;
                    const crushed = Math.round(x * step) / step;
                    // Random digital artifacts (like corrupted samples)
                    curve[i] = Math.random() < 0.95 ? crushed : crushed * (Math.random() * 2 - 1);
                }
                bitCrusher.curve = curve;
                
                // 2. SAMPLE RATE REDUCTION EFFECT (aliasing artifacts)
                // Create high-frequency "fizz" that comes from downsampling
                const aliasingFilter = audioContext.createBiquadFilter();
                aliasingFilter.type = 'highpass';
                aliasingFilter.frequency.value = 8000 - cursorVelocity * 6000; // Velocity adds more aliasing
                aliasingFilter.Q.value = 0.5;
                
                // 3. DIGITAL NOISE LAYER (like digital compression artifacts)
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    // Steppy digital noise (not smooth analog noise)
                    noiseData[i] = Math.round((Math.random() * 2 - 1) * 4) / 4;
                }
                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                noiseSource.loop = true;
                const noiseGain = audioContext.createGain();
                noiseGain.gain.value = 0.03 * (1 + cursorVelocity); // Velocity adds more digital grit
                noiseSource.connect(noiseGain);
                noiseGain.connect(output.context.destination);
                noiseSource.start(now);
                
                // Connect the chain
                output.connect(bitCrusher);
                bitCrusher.connect(aliasingFilter);
                output = aliasingFilter;
            }
            
            /*
             * ═══════════════════════════════════════════════════════════
             * FEEDBACK (↻) - TAPE ECHO TEXTURE
             * ═══════════════════════════════════════════════════════════
             * Visual: Smooth trails, motion blur
             * Sound: Warm tape delay, pitch drift, evolving echoes
             */
            if (glitchEffects.feedback.active) {
                // 1. TAPE-STYLE DELAY (smooth, warm echoes)
                const feedbackDelay = audioContext.createDelay();
                const feedbackGain = audioContext.createGain();
                // Cursor Y position controls delay time (like tape speed)
                feedbackDelay.delayTime.value = 0.05 + mouseY * 0.2;
                // Cursor velocity controls feedback intensity (faster = more echoes)
                feedbackGain.gain.value = glitchState.feedbackAmount * (1 + cursorVelocity * 2);
                
                // 2. TAPE SATURATION (warm analog compression)
                const tapeDistortion = audioContext.createWaveShaper();
                const tapeCurve = new Float32Array(256);
                for (let i = 0; i < 256; i++) {
                    const x = (i / 128) - 1;
                    // Soft clipping like analog tape
                    tapeCurve[i] = Math.tanh(x * 1.5);
                }
                tapeDistortion.curve = tapeCurve;
                
                // 3. PITCH DRIFT (each echo slightly changes pitch - like wow & flutter)
                const pitchMod = audioContext.createOscillator();
                pitchMod.frequency.value = 0.3; // Slow drift
                const pitchModGain = audioContext.createGain();
                pitchModGain.gain.value = 0.02; // Subtle pitch variation
                pitchMod.connect(pitchModGain);
                pitchModGain.connect(feedbackDelay.delayTime);
                pitchMod.start(now);
                
                // 4. FILTER FEEDBACK (echoes get darker over time)
                const feedbackFilter = audioContext.createBiquadFilter();
                feedbackFilter.type = 'lowpass';
                feedbackFilter.frequency.value = 2000 - cursorVelocity * 1000; // Velocity makes it darker
                feedbackFilter.Q.value = 1.5;
                
                // Connect the feedback chain
                output.connect(feedbackDelay);
                feedbackDelay.connect(tapeDistortion);
                tapeDistortion.connect(feedbackFilter);
                feedbackFilter.connect(feedbackGain);
                feedbackGain.connect(feedbackDelay); // Create the feedback loop
                output = feedbackFilter;
            }
            
            /*
             * ═══════════════════════════════════════════════════════════
             * CORRUPT (◆) - DATA CORRUPTION TEXTURE
             * ═══════════════════════════════════════════════════════════
             * Visual: Color inversion, random velocity spikes
             * Sound: Granular chaos, amplitude glitches, buffer corruption
             */
            if (glitchEffects.corrupt.active) {
                // More corruption near edges and with fast movement
                const edgeProximity = Math.max(
                    Math.abs(mouseX - 0.5),
                    Math.abs(mouseY - 0.5)
                ) * 2;
                const corruptChance = glitchState.corruptionRate * (1 + edgeProximity + cursorVelocity * 5);
                
                // 1. PITCH CORRUPTION (sudden frequency jumps)
                if (Math.random() < corruptChance) {
                    audioNodes.oscillators.forEach(osc => {
                        if (osc && osc.frequency) {
                            const jump = Math.random() > 0.5 ? 2 : 0.5;
                            osc.frequency.setValueAtTime(osc.frequency.value * jump, now);
                            osc.frequency.exponentialRampToValueAtTime(osc.frequency.value / jump, now + 0.05);
                        }
                    });
                }
                
                // 2. AMPLITUDE GLITCHES (sudden volume spikes/drops)
                const glitchGate = audioContext.createGain();
                const glitchRate = 10 + cursorVelocity * 50; // Faster movement = more glitches
                const glitchLFO = audioContext.createOscillator();
                glitchLFO.frequency.value = glitchRate;
                glitchLFO.type = 'square'; // Hard on/off glitches
                const glitchDepth = audioContext.createGain();
                glitchDepth.gain.value = 0.5; // Amount of volume modulation
                glitchLFO.connect(glitchDepth);
                glitchDepth.connect(glitchGate.gain);
                glitchLFO.start(now);
                
                // 3. BUFFER CORRUPTION (random audio fragments)
                const corruptionNoise = audioContext.createBufferSource();
                const corruptBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
                const corruptData = corruptBuffer.getChannelData(0);
                for (let i = 0; i < corruptData.length; i++) {
                    // Random bursts (like corrupted buffer reads)
                    corruptData[i] = Math.random() < 0.1 ? (Math.random() * 2 - 1) : 0;
                }
                corruptionNoise.buffer = corruptBuffer;
                corruptionNoise.loop = true;
                const corruptionGain = audioContext.createGain();
                corruptionGain.gain.value = 0.05 * (1 + cursorVelocity * 2);
                corruptionNoise.connect(corruptionGain);
                corruptionGain.connect(output.context.destination);
                corruptionNoise.start(now);
                
                // Connect glitch gate
                output.connect(glitchGate);
                output = glitchGate;
            }
            
            /*
             * ═══════════════════════════════════════════════════════════
             * RGB SPLIT (▣) - SPECTRAL PRISM TEXTURE
             * ═══════════════════════════════════════════════════════════
             * Visual: Colors split into rainbow layers
             * Sound: Frequency splitting, spectral chorus, spatial spread
             */
            if (glitchEffects.rgbSplit.active) {
                // 1. FREQUENCY BAND SPLITTING (like light through prism)
                // Bass = Left, Mids = Center, Highs = Right
                const lowSplit = audioContext.createBiquadFilter();
                lowSplit.type = 'lowpass';
                lowSplit.frequency.value = 300;
                const lowPan = audioContext.createStereoPanner();
                lowPan.pan.value = -0.7; // Left
                
                const midSplit = audioContext.createBiquadFilter();
                midSplit.type = 'bandpass';
                midSplit.frequency.value = 1000;
                midSplit.Q.value = 1.0;
                const midPan = audioContext.createStereoPanner();
                midPan.pan.value = 0; // Center
                
                const highSplit = audioContext.createBiquadFilter();
                highSplit.type = 'highpass';
                highSplit.frequency.value = 3000;
                const highPan = audioContext.createStereoPanner();
                highPan.pan.value = 0.7; // Right
                
                // 2. SPECTRAL CHORUS (multiple detuned copies - shimmer effect)
                const chorus1 = audioContext.createOscillator();
                const chorus2 = audioContext.createOscillator();
                chorus1.frequency.value = 5; // Chorus rate
                chorus2.frequency.value = 7;
                const chorusDepth1 = audioContext.createGain();
                const chorusDepth2 = audioContext.createGain();
                chorusDepth1.gain.value = 5;
                chorusDepth2.gain.value = 8;
                
                // Cursor velocity controls shimmer intensity
                const chorusMix = audioContext.createGain();
                chorusMix.gain.value = 0.3 * (1 + cursorVelocity);
                
                chorus1.connect(chorusDepth1);
                chorus2.connect(chorusDepth2);
                chorus1.start(now);
                chorus2.start(now);
                
                // 3. RAINBOW RESONANCE (add sparkle to each frequency band)
                const lowResonance = audioContext.createBiquadFilter();
                lowResonance.type = 'peaking';
                lowResonance.frequency.value = 200;
                lowResonance.Q.value = 5;
                lowResonance.gain.value = 3;
                
                const highResonance = audioContext.createBiquadFilter();
                highResonance.type = 'peaking';
                highResonance.frequency.value = 5000;
                highResonance.Q.value = 5;
                highResonance.gain.value = 3;
                
                // Connect the spectral split chain
                const merger = audioContext.createChannelMerger(2);
                
                output.connect(lowSplit);
                lowSplit.connect(lowResonance);
                lowResonance.connect(lowPan);
                lowPan.connect(merger, 0, 0);
                
                output.connect(midSplit);
                midSplit.connect(midPan);
                midPan.connect(merger, 0, 0);
                
                output.connect(highSplit);
                highSplit.connect(highResonance);
                highResonance.connect(highPan);
                highPan.connect(merger, 0, 1);
                
                output = merger;
                
                // Cursor X position adds extra panning
                if (audioNodes.panner) {
                    const panAmount = (mouseX - 0.5) * 2;
                    audioNodes.panner.pan.value = Math.max(-1, Math.min(1, panAmount));
                }
            }
            
            /*
             * ═══════════════════════════════════════════════════════════
             * FREEZE (❄) - CRYSTALLINE TIME-STOP TEXTURE
             * ═══════════════════════════════════════════════════════════
             * Visual: Darkened fluid, icy blue tint, stopped motion
             * Sound: Granular freeze, crystalline shimmer, suspended time
             */
            if (glitchEffects.freeze.active) {
                if (!glitchState.freezeFrame) {
                    // Freeze based on cursor Y position
                    const freezeFreq = 200 + mouseY * 1000;
                    glitchState.freezeFrame = {
                        frequency: freezeFreq,
                        time: now
                    };
                    // Apply frozen frequency
                    audioNodes.oscillators.forEach(osc => {
                        if (osc && osc.frequency) {
                            osc.frequency.setValueAtTime(freezeFreq, now);
                        }
                    });
                }
                
                // 1. CRYSTALLINE SHIMMER (high bell-like overtones)
                const crystalOsc1 = audioContext.createOscillator();
                const crystalOsc2 = audioContext.createOscillator();
                const crystalOsc3 = audioContext.createOscillator();
                crystalOsc1.frequency.value = glitchState.freezeFrame.frequency * 8;
                crystalOsc2.frequency.value = glitchState.freezeFrame.frequency * 12;
                crystalOsc3.frequency.value = glitchState.freezeFrame.frequency * 16;
                crystalOsc1.type = 'sine';
                crystalOsc2.type = 'sine';
                crystalOsc3.type = 'sine';
                
                const crystalGain = audioContext.createGain();
                crystalGain.gain.value = 0.02; // Subtle shimmer layer
                crystalOsc1.connect(crystalGain);
                crystalOsc2.connect(crystalGain);
                crystalOsc3.connect(crystalGain);
                crystalGain.connect(output.context.destination);
                crystalOsc1.start(now);
                crystalOsc2.start(now);
                crystalOsc3.start(now);
                
                // 2. FROZEN REVERB (infinite, non-decaying reverb)
                const freezeReverb = audioContext.createConvolver();
                const freezeReverbBuffer = audioContext.createBuffer(2, audioContext.sampleRate * 8, audioContext.sampleRate);
                const freezeL = freezeReverbBuffer.getChannelData(0);
                const freezeR = freezeReverbBuffer.getChannelData(1);
                for (let i = 0; i < freezeL.length; i++) {
                    // Very slow decay - sound hangs in the air
                    freezeL[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / freezeL.length, 0.5);
                    freezeR[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / freezeR.length, 0.5);
                }
                freezeReverb.buffer = freezeReverbBuffer;
                
                const freezeReverbGain = audioContext.createGain();
                freezeReverbGain.gain.value = 0.6; // Strong reverb presence
                
                // 3. ICE FILTER (high resonance for glass-like quality)
                const iceFilter = audioContext.createBiquadFilter();
                iceFilter.type = 'highpass';
                iceFilter.frequency.value = 2000;
                iceFilter.Q.value = 8; // High resonance = crystalline
                
                // Connect freeze chain
                output.connect(iceFilter);
                iceFilter.connect(freezeReverb);
                freezeReverb.connect(freezeReverbGain);
                freezeReverbGain.connect(output.context.destination);
                
            } else {
                glitchState.freezeFrame = null;
            }
            
            return { ...audioNodes, output };
        }
        
        // Apply visual glitches to the fluid simulation
        function applyVisualGlitches() {
            // Reset color and diffusion to base values (fixes color drift bug)
            if (selectedColorIndex >= 0) {
                const voice = colorVoices[selectedColorIndex];
                currentDynamicColor = { ...voice.color };
                currentDiffusion = voice.diffusion;
            }
            
            // Bit Crush - EXTREME PIXELATION EFFECT with color quantization
            if (glitchEffects.bitCrush.active) {
                // EXTREME: Dramatically reduce diffusion for super blocky effect
                currentDiffusion *= 0.15; // Much more blocky than before
                
                // COLOR QUANTIZATION - reduce to limited color palette (like 8-bit graphics)
                if (selectedColorIndex >= 0) {
                    const voice = colorVoices[selectedColorIndex];
                    const colorLevels = 4; // Only 4 shades per channel = 64 total colors
                    currentDynamicColor.r = Math.floor(voice.color.r * colorLevels) / colorLevels;
                    currentDynamicColor.g = Math.floor(voice.color.g * colorLevels) / colorLevels;
                    currentDynamicColor.b = Math.floor(voice.color.b * colorLevels) / colorLevels;
                }
                
                // Create MULTIPLE pixelated splats constantly for extreme effect
                const numSplats = 3; // Multiple splats per frame
                for (let i = 0; i < numSplats; i++) {
                    const gridSize = glitchState.pixelSize;
                    
                    // Snap to pixel grid with random offset for glitchy look
                    const offsetX = (Math.random() > 0.8) ? (1 / gridSize) : 0;
                    const offsetY = (Math.random() > 0.8) ? (1 / gridSize) : 0;
                    const gridX = Math.floor(mouseX * gridSize) / gridSize + (0.5 / gridSize) + offsetX;
                    const gridY = Math.floor(mouseY * gridSize) / gridSize + (0.5 / gridSize) + offsetY;
                    
                    // Velocity splat - HUGE radius for massive pixels
                    gl.useProgram(splatProgram);
                    const posLoc = gl.getAttribLocation(splatProgram, 'position');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(velocity.write);
                    gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), gridX, gridY);
                    gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                        mouseVelX * 5, mouseVelY * 5, 0.0
                    );
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.04); // HUGE pixels
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    velocity.swap();
                    
                    // Pixelated color splats with quantized colors
                    if (selectedColorIndex >= 0 && colorSplatProgram) {
                        const voice = colorVoices[selectedColorIndex];
                        
                        gl.useProgram(colorSplatProgram);
                        const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                        gl.enableVertexAttribArray(colorPosLoc);
                        gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                        
                        bindFramebuffer(colorBuffer.write);
                        gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                        gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), gridX, gridY);
                        
                        // Quantized colors (limited palette like old video games)
                        const levels = 4;
                        const r = Math.floor(voice.color.r * levels) / levels;
                        const g = Math.floor(voice.color.g * levels) / levels;
                        const b = Math.floor(voice.color.b * levels) / levels;
                        
                        gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                            r * 0.7, 
                            g * 0.7, 
                            b * 0.7
                        );
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.035); // HUGE color blocks
                        
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        colorBuffer.swap();
                    }
                }
                
                // GLITCH ARTIFACTS - random pixel corruption
                if (Math.random() < 0.2) {
                    const gridSize = glitchState.pixelSize;
                    const randomX = Math.floor(Math.random() * gridSize) / gridSize;
                    const randomY = Math.floor(Math.random() * gridSize) / gridSize;
                    
                    gl.useProgram(splatProgram);
                    const posLoc = gl.getAttribLocation(splatProgram, 'position');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(velocity.write);
                    gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), randomX, randomY);
                    gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                        (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, 0.0
                    );
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.02);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    velocity.swap();
                }
            }
            
            // Corrupt - chaos radiating from cursor + COLOR INVERSION
            if (glitchEffects.corrupt.active) {
                // Invert colors based on cursor proximity and movement
                const cursorVelocity = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
                if (selectedColorIndex >= 0 && cursorVelocity > 0.01) {
                    const voice = colorVoices[selectedColorIndex];
                    // Invert colors: subtract from 1.0
                    currentDynamicColor.r = 1.0 - voice.color.r;
                    currentDynamicColor.g = 1.0 - voice.color.g;
                    currentDynamicColor.b = 1.0 - voice.color.b;
                }
                
                // Spawn corruption near cursor
                if (Math.random() < glitchState.corruptionRate * 3) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 0.2;
                    const x = mouseX + Math.cos(angle) * dist;
                    const y = mouseY + Math.sin(angle) * dist;
                    const force = 8 + Math.random() * 15;
                    
                    gl.useProgram(splatProgram);
                    const posLoc = gl.getAttribLocation(splatProgram, 'position');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(velocity.write);
                    gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), x, y);
                    gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                        Math.cos(angle) * force, 
                        Math.sin(angle) * force, 
                        0.0
                    );
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.002 + Math.random() * 0.008);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    velocity.swap();
                    
                    // Inject inverted color splats at corruption points
                    if (selectedColorIndex >= 0 && colorSplatProgram) {
                        const voice = colorVoices[selectedColorIndex];
                        
                        gl.useProgram(colorSplatProgram);
                        const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                        gl.enableVertexAttribArray(colorPosLoc);
                        gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                        
                        bindFramebuffer(colorBuffer.write);
                        gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                        gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), x, y);
                        
                        // INVERTED colors at corruption points
                        gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                            (1.0 - voice.color.r) * 0.8,
                            (1.0 - voice.color.g) * 0.8,
                            (1.0 - voice.color.b) * 0.8
                        );
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.004);
                        
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        colorBuffer.swap();
                    }
                }
            }
            
            // RGB Split - PRISM EFFECT with multiple color layers (cursor-responsive)
            if (glitchEffects.rgbSplit.active && selectedColorIndex >= 0 && colorSplatProgram) {
                const voice = colorVoices[selectedColorIndex];
                const cursorInfluence = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
                
                // Create multiple color layers (prism effect)
                for (let i = 0; i < glitchState.prismLayers; i++) {
                    const angle = (i / glitchState.prismLayers) * Math.PI * 2;
                    const offset = glitchState.rgbSplitAmount * (1 + cursorInfluence * 5);
                    const splitX = mouseX + Math.cos(angle) * offset;
                    const splitY = mouseY + Math.sin(angle) * offset;
                    
                    // Shift hue for each layer
                    const hueShift = i / glitchState.prismLayers;
                    const r = voice.color.r * (1 - hueShift) + hueShift;
                    const g = voice.color.g * (1 - hueShift * 0.5) + hueShift * 0.5;
                    const b = voice.color.b * (1 - hueShift * 0.3) + hueShift * 0.7;
                    
                    gl.useProgram(colorSplatProgram);
                    const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                    gl.enableVertexAttribArray(colorPosLoc);
                    gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(colorBuffer.write);
                    gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), splitX, splitY);
                    gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), r * 0.3, g * 0.3, b * 0.3);
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.002);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    colorBuffer.swap();
                }
            }
            
            // Feedback - trails following cursor path
            if (glitchEffects.feedback.active) {
                const velocity = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
                currentDiffusion *= 1.2 + velocity * 2; // Stronger trails when moving fast
            }
            
            // Freeze - DARKENS entire fluid + freezes motion at cursor
            if (glitchEffects.freeze.active) {
                // DARKEN the entire fluid - creates frozen/crystallized appearance
                if (selectedColorIndex >= 0) {
                    const voice = colorVoices[selectedColorIndex];
                    // Dramatically darken colors (multiply by 0.3 = 70% darker)
                    currentDynamicColor.r = voice.color.r * 0.3;
                    currentDynamicColor.g = voice.color.g * 0.3;
                    currentDynamicColor.b = voice.color.b * 0.3;
                    
                    // Add icy blue tint
                    currentDynamicColor.b += 0.1;
                }
                
                // Reduce diffusion for sharper, frozen texture
                currentDiffusion *= 0.4;
                
                // Create freeze effect at cursor - counter-velocity to stop motion
                gl.useProgram(splatProgram);
                const posLoc = gl.getAttribLocation(splatProgram, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                bindFramebuffer(velocity.write);
                gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), mouseX, mouseY);
                gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                    -mouseVelX * 0.5, -mouseVelY * 0.5, 0.0 // Counter-velocity
                );
                gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.05);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                velocity.swap();
                
                // Inject dark frozen color splats around cursor
                if (selectedColorIndex >= 0 && colorSplatProgram) {
                    const voice = colorVoices[selectedColorIndex];
                    
                    gl.useProgram(colorSplatProgram);
                    const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                    gl.enableVertexAttribArray(colorPosLoc);
                    gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(colorBuffer.write);
                    gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), mouseX, mouseY);
                    
                    // Dark frozen colors with blue tint
                    gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                        voice.color.r * 0.2,
                        voice.color.g * 0.2,
                        voice.color.b * 0.3 + 0.1 // Blue tint
                    );
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.01);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    colorBuffer.swap();
                }
            }
        }

        const vertexShaderSource = `
            attribute vec2 position;
            varying vec2 vUv;
            void main() {
                vUv = position * 0.5 + 0.5;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const advectionShaderSource = `
            precision mediump float;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform float dt;
            uniform float dissipation;
            varying vec2 vUv;
            
            void main() {
                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                gl_FragColor = dissipation * texture2D(uSource, coord);
            }
        `;

        const diffusionShaderSource = `
            precision mediump float;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform float diffusionRate;
            varying vec2 vUv;
            
            void main() {
                // Diffusion creates organic spreading like ink in water
                vec3 center = texture2D(uSource, vUv).rgb;
                vec3 left = texture2D(uSource, vUv - vec2(texelSize.x, 0.0)).rgb;
                vec3 right = texture2D(uSource, vUv + vec2(texelSize.x, 0.0)).rgb;
                vec3 top = texture2D(uSource, vUv + vec2(0.0, texelSize.y)).rgb;
                vec3 bottom = texture2D(uSource, vUv - vec2(0.0, texelSize.y)).rgb;
                
                // Laplacian diffusion - creates natural spreading
                vec3 laplacian = left + right + top + bottom - 4.0 * center;
                vec3 diffused = center + laplacian * diffusionRate;
                
                gl_FragColor = vec4(diffused, 1.0);
            }
        `;

        const divergenceShaderSource = `
            precision mediump float;
            uniform sampler2D uVelocity;
            uniform vec2 texelSize;
            varying vec2 vUv;
            
            void main() {
                float L = texture2D(uVelocity, vUv - vec2(texelSize.x, 0.0)).x;
                float R = texture2D(uVelocity, vUv + vec2(texelSize.x, 0.0)).x;
                float T = texture2D(uVelocity, vUv + vec2(0.0, texelSize.y)).y;
                float B = texture2D(uVelocity, vUv - vec2(0.0, texelSize.y)).y;
                
                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `;

        const pressureShaderSource = `
            precision mediump float;
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;
            uniform vec2 texelSize;
            varying vec2 vUv;
            
            void main() {
                float L = texture2D(uPressure, vUv - vec2(texelSize.x, 0.0)).x;
                float R = texture2D(uPressure, vUv + vec2(texelSize.x, 0.0)).x;
                float T = texture2D(uPressure, vUv + vec2(0.0, texelSize.y)).x;
                float B = texture2D(uPressure, vUv - vec2(0.0, texelSize.y)).x;
                float C = texture2D(uDivergence, vUv).x;
                
                gl_FragColor = vec4((L + R + B + T - C) * 0.25, 0.0, 0.0, 1.0);
            }
        `;

        const gradientSubtractShaderSource = `
            precision mediump float;
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;
            uniform vec2 texelSize;
            varying vec2 vUv;
            
            void main() {
                float L = texture2D(uPressure, vUv - vec2(texelSize.x, 0.0)).x;
                float R = texture2D(uPressure, vUv + vec2(texelSize.x, 0.0)).x;
                float T = texture2D(uPressure, vUv + vec2(0.0, texelSize.y)).x;
                float B = texture2D(uPressure, vUv - vec2(0.0, texelSize.y)).x;
                
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity.xy -= vec2(R - L, T - B) * 0.5;
                
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `;

        const splatShaderSource = `
            precision mediump float;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec2 point;
            uniform vec3 color;
            uniform float radius;
            varying vec2 vUv;
            
            void main() {
                vec2 p = vUv - point;
                p.x *= aspectRatio;
                
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `;

        const colorSplatShaderSource = `
            precision mediump float;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec2 point;
            uniform vec3 color;
            uniform float radius;
            varying vec2 vUv;
            
            void main() {
                vec2 p = vUv - point;
                p.x *= aspectRatio;
                
                float dist = length(p);
                
                // Concentrated ink drop - small, intense center
                float intensity = exp(-dist * dist / (radius * 0.3));
                
                vec3 splat = color * intensity;
                vec4 base = texture2D(uTarget, vUv);
                
                // Add ink drop
                vec3 newColor = base.rgb + splat;
                newColor = clamp(newColor, 0.0, 1.0);
                
                gl_FragColor = vec4(newColor, 1.0);
            }
        `;

        const displayShaderSource = `
            precision mediump float;
            uniform sampler2D uVelocity;
            uniform sampler2D uColor;
            uniform float time;
            uniform vec2 resolution;
            varying vec2 vUv;
            
            const float PI = 3.141592654;
            const float scale = 0.25;
            const vec4 a = vec4(4.5, 6.0, 8.0, 11.0);
            const vec2 b = vec2(1.0, 1.0);
            
            const vec3 baseColor1 = vec3(0.95);
            const vec3 baseColor2 = vec3(0.66, 0.67, 0.70);
            const vec3 baseColor3 = vec3(0.35, 0.37, 0.42);
            const vec3 baseColor4 = vec3(0.56, 0.57, 0.62);
            
            float cheapNoise(vec3 p) {
                float s1 = sin(p.z + p.x * a.x + cos(p.x * a.x - p.z));
                float c1 = cos(p.z + p.y * a.y + cos(p.y * a.x + p.z));
                float s2 = sin(1.0 + p.x * a.z + p.z + cos(p.y * a.w - p.z));
                float c2 = cos(1.0 + p.y * a.w + p.z + cos(p.x * a.x + p.z));
                return s1 * c1 * 0.564 + s2 * c2 * 0.436;
            }
            
            void main() {
                vec2 aR = vec2(resolution.x / resolution.y, 1.0);
                vec2 st = vUv * aR * scale;
                
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                vec3 inkColor = texture2D(uColor, vUv).rgb;
                float inkPresence = length(inkColor);
                
                vec2 fluidDistortion = velocity * 3.0;
                
                float t = time * 0.008;
                float S = sin(t);
                float C = cos(t);
                
                vec3 stMod = vec3(st + fluidDistortion * 0.5, 0.0);
                
                vec2 v1 = vec2(
                    cheapNoise(stMod + vec3(0.0, 0.0, 2.0)),
                    cheapNoise(stMod + vec3(0.0, 0.0, 1.0))
                );
                
                vec2 offset1 = vec2(C * 1.7, S * 9.2) + fluidDistortion * 0.3;
                vec2 offset2 = vec2(S * 8.3, C * 2.8) + fluidDistortion * 0.3;
                
                vec2 v2 = vec2(
                    cheapNoise(vec3(st + b.x * v1 + offset1, 0.12 * time)),
                    cheapNoise(vec3(st + b.y * v1 + offset2, 0.10 * time))
                );
                
                float n = 0.5 + 0.5 * cheapNoise(vec3(st + v2 + fluidDistortion * 0.2, 0.0));
                float nn = n * n;
                
                // Generate base metallic grey
                vec3 metallic = mix(baseColor1, baseColor2, clamp(nn * 8.0, 0.0, 1.0));
                metallic = mix(metallic, baseColor3, clamp(length(v1), 0.0, 1.0));
                metallic = mix(metallic, baseColor4, clamp(length(v2.x), 0.0, 1.0));
                
                float velocityMag = length(velocity);
                metallic += vec3(0.2) * velocityMag;
                metallic /= nn + n * 7.0;
                
                // Where ink is present, it colors the metallic liquid
                if (inkPresence > 0.05) {
                    // Normalize ink to get hue
                    vec3 inkHue = inkPresence > 0.0 ? inkColor / inkPresence : vec3(0.0);
                    
                    // Extract metallic luminosity structure
                    float lum = dot(metallic, vec3(0.299, 0.587, 0.114));
                    
                    // Tint the metallic with ink hue, preserving structure
                    vec3 tintedMetallic = inkHue * lum * 1.2;
                    
                    // Nearly full replacement - very opaque
                    float blend = smoothstep(0.05, 0.3, inkPresence) * 0.95;
                    metallic = mix(metallic, tintedMetallic, blend);
                }
                
                // Prevent extreme whites
                metallic = clamp(metallic, 0.0, 0.7);
                
                gl_FragColor = vec4(metallic, 1.0);
            }
        `;

        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(vertSource, fragSource) {
            const vertShader = compileShader(gl.VERTEX_SHADER, vertSource);
            const fragShader = compileShader(gl.FRAGMENT_SHADER, fragSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }

        const advectionProgram = createProgram(vertexShaderSource, advectionShaderSource);
        const diffusionProgram = createProgram(vertexShaderSource, diffusionShaderSource);
        const divergenceProgram = createProgram(vertexShaderSource, divergenceShaderSource);
        const pressureProgram = createProgram(vertexShaderSource, pressureShaderSource);
        const gradientSubtractProgram = createProgram(vertexShaderSource, gradientSubtractShaderSource);
        const splatProgram = createProgram(vertexShaderSource, splatShaderSource);
        const colorSplatProgram = createProgram(vertexShaderSource, colorSplatShaderSource);
        const displayProgram = createProgram(vertexShaderSource, displayShaderSource);

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        function createFramebuffer(width, height) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);
            
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            
            return { fbo, texture, width, height };
        }

        function createDoubleFBO(width, height) {
            return {
                read: createFramebuffer(width, height),
                write: createFramebuffer(width, height),
                swap: function() {
                    const temp = this.read;
                    this.read = this.write;
                    this.write = temp;
                }
            };
        }

        const velocity = createDoubleFBO(simWidth, simHeight);
        const divergence = createFramebuffer(simWidth, simHeight);
        const pressure = createDoubleFBO(simWidth, simHeight);
        const colorBuffer = createDoubleFBO(simWidth, simHeight);

        // Initialize color buffer to completely empty
        gl.viewport(0, 0, simWidth, simHeight);
        gl.bindFramebuffer(gl.FRAMEBUFFER, colorBuffer.read.fbo);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, colorBuffer.write.fbo);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // Mouse and interaction state
        let mouseX = 0.5;
        let mouseY = 0.5;
        let lastMouseX = 0.5;
        let lastMouseY = 0.5;
        let mouseVelX = 0;
        let mouseVelY = 0;
        let prevVelocityMag = 0;
        let acceleration = 0;
        let movementMomentum = 0;
        let areaConcentration = 0;
        let turbulence = 0;
        let recentPositions = [];
        let recentVelocities = [];
        let pendingClicks = [];
        const MAX_POSITIONS = 20;
        const MAX_VELOCITIES = 10;

        // ===== GENERAL PAINTING VELOCITY TRACKING =====
        /*
         * Track painting speed for volume and brightness control
         * Faster painting = louder and brighter sounds
         */
        let currentPaintingVelocity = 0;
        let lastPaintingPos = { x: mouseX, y: mouseY };
        let lastPaintingTime = Date.now();
        let velocitySmoothing = 0.7; // Smooth velocity changes
        
        // ===== GESTURE CURVATURE TRACKING =====
        /*
         * Track how curved vs straight the gesture is
         * Curved gestures create subtle timbral variations
         */
        let gestureCurvature = 0; // 0 = straight, 1 = very curved
        let gestureHistory = []; // Last few positions
        const MAX_GESTURE_HISTORY = 5;

        // ===== ORAMICS GESTURE TRACKING =====
        /*
         * Track gesture metrics for Painted Envelope effect
         * Inspired by Daphne Oram's Oramics - where the physical gesture
         * shape directly controls the sound envelope
         */
        let gestureStartTime = 0;
        let gesturePathLength = 0;
        let gestureAvgVelocity = 0;
        let isGestureActive = false;
        let lastGesturePos = { x: 0, y: 0 };

        // ===== PATTERN SEQUENCER ZONES =====
        /*
         * Pattern Sequencer: Paint zones on canvas that trigger notes
         * when fluid flows through them. Like a visual step sequencer!
         * EXTREME MODE: Much faster, more sensitive, louder!
         */
        let sequencerZones = []; // Array of {x, y, color, lastTriggerTime}
        const ZONE_TRIGGER_COOLDOWN = 150; // ms between triggers (MUCH faster retriggering!)
        const ZONE_DETECTION_RADIUS = 0.15; // How close fluid needs to be (WIDER detection!)

        // ===== GESTURE DRONES =====
        /*
         * Gesture Drones: Sustained painting creates evolving ambient layers
         * that continue playing and morphing over time
         */
        let activeDrones = []; // Array of {osc, gain, color, startTime}
        const MAX_DRONES = 6; // Maximum simultaneous drones
        let droneStartTime = 0;
        const DRONE_ACTIVATION_TIME = 800; // ms of sustained painting to start drone

        // ===== RHYTHMIC PATTERN EFFECTS =====
        /*
         * Arpeggiator, Stutter, and Polyrhythm effects
         * These modify how sounds are triggered
         */
        // Arpeggiator state
        let arpNoteIndex = 0;
        const arpPattern = [0, 4, 7, 12]; // Major triad + octave (semitones)
        
        // Stutter state
        let stutterBuffer = []; // Recent sound events
        let lastStutterTime = 0;
        const STUTTER_INTERVAL = 150; // ms between stutters
        
        // Polyrhythm state
        let polyrhythmTimers = [];
        const POLYRHYTHM_DIVISIONS = [3, 5, 7]; // Triplets, quintuplets, septuplets
        
        // Color morphing for rhythmic effects
        // Maps each color to its morph target color
        const colorMorphMap = {
            0: 3, // Grey → Yellow
            1: 5, // Brown → Pink
            2: 4, // Blue → Green
            3: 2, // Yellow → Blue
            4: 0, // Green → Grey
            5: 1, // Pink → Brown
            6: 3  // Red → Yellow
        };
        
        // Color trail state for rhythmic effects
        let previousPaintPositions = []; // Store recent positions for trail effect
        const MAX_TRAIL_LENGTH = 12; // How many trail positions to keep (longer rainbow!)

        // ===== DRAWN WAVEFORMS (ORAMICS) =====
        /*
         * Read visual pattern from screen and convert to audio waveform
         * Like Oram's photoelectric film reader
         */
        let visualWaveformBuffer = null;
        let lastWaveformUpdateTime = 0;
        const WAVEFORM_UPDATE_RATE = 100; // Update every 100ms

        /**
         * Sample visual brightness across a horizontal line
         * Convert pixel brightness → audio amplitude
         * This is the core Oramics technique!
         */
        function sampleVisualWaveform() {
            if (!gl || !colorBuffer) return null;

            const sampleCount = 256; // Number of samples for waveform (powers of 2 work best)
            const waveformData = new Float32Array(sampleCount);
            
            // Read pixels from the middle horizontal line of the canvas
            const scanY = Math.floor(canvas.height * 0.5);
            const pixels = new Uint8Array(canvas.width * 4); // RGBA
            
            try {
                // Read pixel data from canvas
                gl.readPixels(0, scanY, canvas.width, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                
                // Convert pixel brightness to waveform amplitude
                for (let i = 0; i < sampleCount; i++) {
                    const pixelIndex = Math.floor((i / sampleCount) * canvas.width);
                    const pixelOffset = pixelIndex * 4;
                    
                    // Calculate brightness from RGB (perceived luminance)
                    const r = pixels[pixelOffset] / 255;
                    const g = pixels[pixelOffset + 1] / 255;
                    const b = pixels[pixelOffset + 2] / 255;
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    
                    // Convert brightness (0-1) to audio amplitude (-1 to 1)
                    waveformData[i] = (brightness * 2) - 1;
                }
                
                return waveformData;
            } catch (e) {
                console.log('Could not read visual waveform:', e);
                return null;
            }
        }

        /**
         * Create audio buffer from visual waveform data
         */
        function createWaveformBuffer(waveformData) {
            if (!audioContext || !waveformData) return null;
            
            const buffer = audioContext.createBuffer(1, waveformData.length, audioContext.sampleRate);
            const channelData = buffer.getChannelData(0);
            
            // Copy waveform data to audio buffer
            for (let i = 0; i < waveformData.length; i++) {
                channelData[i] = waveformData[i];
            }
            
            return buffer;
        }

        // ===== GESTURE DRONE FUNCTIONS =====
        /**
         * Create a new evolving ambient drone layer
         * Drones slowly morph in frequency and filter over time
         */
        function createDrone(color, position) {
            if (!audioContext || activeDrones.length >= MAX_DRONES) return;

            try {
                // Create oscillator for drone base
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();

                // Get frequency from color
                const freq = getColorFrequency(color);
                
                // Drones are pitched down an octave or two for ambient feel
                const droneFreq = freq / (2 + Math.random()); // Random sub-octave
                osc.frequency.value = droneFreq;
                osc.type = 'triangle'; // Smooth timbre for drones

                // Setup filter for evolving texture
                filter.type = 'lowpass';
                filter.frequency.value = 400 + Math.random() * 1200;
                filter.Q.value = 1 + Math.random() * 3;

                // Start very quiet and fade in slowly to a MORE AUDIBLE level
                gain.gain.value = 0;
                gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 3); // 3s fade in (nearly 2x louder!)

                // Connect: osc → filter → gain → master
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);

                osc.start();

                // Store drone info
                const drone = {
                    osc,
                    gain,
                    filter,
                    color,
                    startTime: Date.now(),
                    baseFreq: droneFreq,
                    position
                };
                activeDrones.push(drone);

                console.log('🎵 Drone created:', color, 'at', droneFreq.toFixed(1), 'Hz');

                // Auto-fade out after 10-20 seconds
                const lifetime = 10000 + Math.random() * 10000;
                setTimeout(() => removeDrone(drone), lifetime);

            } catch (e) {
                console.log('Could not create drone:', e);
            }
        }

        /**
         * Remove a drone with smooth fade out
         */
        function removeDrone(drone) {
            if (!drone || !drone.gain) return;

            try {
                const fadeTime = audioContext.currentTime + 2;
                drone.gain.gain.linearRampToValueAtTime(0, fadeTime);

                setTimeout(() => {
                    if (drone.osc) drone.osc.stop();
                    if (drone.osc) drone.osc.disconnect();
                    if (drone.filter) drone.filter.disconnect();
                    if (drone.gain) drone.gain.disconnect();
                    
                    // Remove from active drones array
                    const index = activeDrones.indexOf(drone);
                    if (index > -1) {
                        activeDrones.splice(index, 1);
                    }
                }, 2100);
            } catch (e) {
                console.log('Error removing drone:', e);
            }
        }

        /**
         * Evolve all active drones over time
         * Slowly modulate frequency and filter for ambient texture
         */
        function evolveDrones() {
            const now = Date.now();
            
            activeDrones.forEach(drone => {
                const age = (now - drone.startTime) / 1000; // seconds
                
                // Slowly drift frequency (like analog drift)
                const drift = Math.sin(age * 0.3) * 10; // ±10 Hz drift
                drone.osc.frequency.value = drone.baseFreq + drift;

                // Evolve filter cutoff
                const filterLFO = Math.sin(age * 0.5) * 600 + 800; // 200-1400 Hz
                drone.filter.frequency.value = filterLFO;
            });
        }

        /**
         * Stop all drones (cleanup)
         */
        function stopAllDrones() {
            activeDrones.forEach(drone => {
                try {
                    if (drone.osc) drone.osc.stop();
                    if (drone.osc) drone.osc.disconnect();
                    if (drone.filter) drone.filter.disconnect();
                    if (drone.gain) drone.gain.disconnect();
                } catch (e) {
                    // Already stopped
                }
            });
            activeDrones = [];
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX / rect.width;
            mouseY = 1.0 - e.clientY / rect.height;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX / rect.width;
            const clickY = 1.0 - e.clientY / rect.height;
            
            pendingClicks.push({ x: clickX, y: clickY });
            
            if (audioEnabled) {
                createSplashSound(clickX, clickY);
            }
        });

        let lastTouchSoundTime = 0;
        
        let lastTouchMoveTime = 0;
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                const newX = e.touches[0].clientX / rect.width;
                const newY = 1.0 - e.touches[0].clientY / rect.height;
                
                // Update mouse position (for deltaX/deltaY in render loop)
                mouseX = newX;
                mouseY = newY;
                
                // Throttled splat injection (every 50ms) to avoid spam
                const now = Date.now();
                if (now - lastTouchMoveTime > 50) {
                    pendingClicks.push({ x: mouseX, y: mouseY });
                    lastTouchMoveTime = now;
                    console.log('💧 Touch move splat added at', mouseX.toFixed(3), mouseY.toFixed(3), '- Total now:', pendingClicks.length);
                    
                    // FORCE visible feedback for iOS debugging
                    document.body.style.backgroundColor = 'rgba(255,0,255,0.3)'; // Magenta flash
                    setTimeout(() => document.body.style.backgroundColor = '#000', 200);
                }
            }
        }, { passive: false });
        
        // Diagnostic removed - audio working!
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 0) return; // Safety check
            
            // iOS: Resume audio context if suspended (critical for iOS)
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('✓ Audio resumed on touch');
                });
            }
            
            isMouseDown = true; // Set for sustained interactions
            const rect = canvas.getBoundingClientRect();
            const clickX = e.touches[0].clientX / rect.width;
            const clickY = 1.0 - e.touches[0].clientY / rect.height;
            
            console.log('👆 Touch start:', clickX.toFixed(2), clickY.toFixed(2));
            
            pendingClicks.push({ x: clickX, y: clickY });
            
            console.log('📍 Touch start at:', clickX.toFixed(3), clickY.toFixed(3));
            
            // Simple test beep (quieter now that audio works)
            if (audioContext && audioContext.state === 'running') {
                try {
                    const testOsc = audioContext.createOscillator();
                    const testGain = audioContext.createGain();
                    testOsc.frequency.value = 440; 
                    testGain.gain.value = 0.1; // Much quieter
                    testOsc.connect(testGain);
                    testGain.connect(audioContext.destination);
                    testOsc.start(audioContext.currentTime);
                    testOsc.stop(audioContext.currentTime + 0.1); // Shorter
                    console.log('🎵 Test beep');
                } catch (e) {
                    console.log('❌ Test tone failed:', e);
                }
            }
            
            if (audioEnabled) {
                createSplashSound(clickX, clickY);
                console.log('🔊 createSplashSound called');
            } else {
                console.log('⚠️ Audio NOT enabled - select color first!');
            }

            // Pattern Sequencer: Mark this position as a trigger zone
            if (oramicsEffects.patternSequencer.active) {
                sequencerZones.push({
                    x: clickX,
                    y: clickY,
                    color: currentColor,
                    lastTriggerTime: 0 // Never triggered yet
                });
                console.log('⊞ Sequencer zone added at', clickX.toFixed(2), clickY.toFixed(2), currentColor);
            }

            // Gesture Drones: Start tracking for sustained gesture
            if (oramicsEffects.gestureDrones.active) {
                droneStartTime = Date.now();
                
                // Check periodically if gesture is sustained long enough
                const checkDroneActivation = setInterval(() => {
                    if (!isMouseDown) {
                        clearInterval(checkDroneActivation);
                        return;
                    }

                    const sustainedTime = Date.now() - droneStartTime;
                    if (sustainedTime >= DRONE_ACTIVATION_TIME) {
                        // Create drone!
                        createDrone(currentColor, { x: clickX, y: clickY });
                        clearInterval(checkDroneActivation);
                    }
                }, 100); // Check every 100ms
            }
        }, { passive: false });

        // ===== MOUSE DOWN/UP FOR SUSTAINED INTERACTIONS =====
        let isMouseDown = false;
        
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX / rect.width;
            const y = 1.0 - e.clientY / rect.height;

            // Pattern Sequencer: Mark this position as a trigger zone
            if (oramicsEffects.patternSequencer.active) {
                sequencerZones.push({
                    x: x,
                    y: y,
                    color: currentColor,
                    lastTriggerTime: 0 // Never triggered yet
                });
                console.log('⊞ Sequencer zone added at', x.toFixed(2), y.toFixed(2), currentColor);
            }

            // Gesture Drones: Start tracking for sustained gesture
            if (oramicsEffects.gestureDrones.active) {
                droneStartTime = Date.now();
                
                // Check periodically if gesture is sustained long enough
                const checkDroneActivation = setInterval(() => {
                    if (!isMouseDown) {
                        clearInterval(checkDroneActivation);
                        return;
                    }

                    const sustainedTime = Date.now() - droneStartTime;
                    if (sustainedTime >= DRONE_ACTIVATION_TIME) {
                        // Create drone!
                        createDrone(currentColor, { x, y });
                        clearInterval(checkDroneActivation);
                    }
                }, 100); // Check every 100ms
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isMouseDown = false;
            droneStartTime = 0; // Reset drone timer
        });

        canvas.addEventListener('mouseleave', (e) => {
            isMouseDown = false;
            droneStartTime = 0; // Reset if mouse leaves canvas
        });

        // ===== TOUCH EQUIVALENTS FOR SUSTAINED INTERACTIONS =====
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isMouseDown = false;
            droneStartTime = 0; // Reset drone timer
        }, { passive: false });

        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            isMouseDown = false;
            droneStartTime = 0; // Reset if touch is cancelled
        }, { passive: false });

        function bindFramebuffer(target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            gl.viewport(0, 0, target.width, target.height);
        }

        // ===== AUDIO ENGINE =====
        let audioContext = null;
        let audioEnabled = false;
        
        let masterGain;
        let convolver, convolverGain;
        let lastSoundTime = 0;
        let rootDrone, rootGain;
        let echoTone, echoGain, echoFilter;
        let lastColorIntensity = 0;
        
        async function initAudio() {
            console.log('🎵 initAudio() called');
            
            // iOS-specific: Use webkit prefix and handle suspended state
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('✓ AudioContext created, state:', audioContext.state);
            } catch (e) {
                console.error('❌ Failed to create AudioContext:', e);
                return;
            }
            
            // iOS CRITICAL: MUST await resume() to properly unlock audio
            console.log('⏸ Audio context state:', audioContext.state);
            if (audioContext.state === 'suspended') {
                console.log('⏸ Resuming audio context...');
                try {
                    await audioContext.resume();
                    console.log('✓ Audio resumed! State now:', audioContext.state);
                } catch (e) {
                    console.error('❌ Resume failed:', e);
                    return;
                }
            }
            
            if (audioContext.state !== 'running') {
                console.error('⚠️ Audio state is:', audioContext.state, '- Not running!');
                return;
            }
            
            console.log('✅ Audio context running!');
            
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioContext.destination);
            
            convolver = audioContext.createConvolver();
            convolverGain = audioContext.createGain();
            convolverGain.gain.value = 0.7;
            convolver.connect(convolverGain);
            convolverGain.connect(masterGain);
            
            /*
             * REVERB IMPULSE RESPONSE:
             * Creating a synthetic reverb that simulates sound bouncing in a space
             * - Longer length = bigger space (4 seconds = cathedral-like)
             * - The decay curve creates natural-sounding reflections
             */
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * 4;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            const impulseL = impulse.getChannelData(0);
            const impulseR = impulse.getChannelData(1);
            
            for (let i = 0; i < length; i++) {
                impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3.5);
                impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3.5);
            }
            convolver.buffer = impulse;
            
            /*
             * ROOT DRONE:
             * A subtle background tone that provides harmonic foundation
             * - Plays the ROOT NOTE of our scale
             * - Very quiet, just gives a sense of "key"
             */
            rootGain = audioContext.createGain();
            rootGain.gain.value = 0.0;
            
            rootDrone = audioContext.createOscillator();
            rootDrone.type = 'sine';
            rootDrone.frequency.value = midiToFreq(musicalSettings.rootNote - 12);  // Root note, one octave below
            
            const rootFilter = audioContext.createBiquadFilter();
            rootFilter.type = 'lowpass';
            rootFilter.frequency.value = 300;
            rootFilter.Q.value = 1;
            
            rootDrone.connect(rootFilter);
            rootFilter.connect(rootGain);
            rootGain.connect(convolver);
            rootDrone.start();
            
            /*
             * ECHO TONE:
             * A second drone playing the FIFTH (7 semitones up)
             * - The fifth is the most consonant interval after the octave
             * - Together with the root, creates a stable, open sound
             */
            echoGain = audioContext.createGain();
            echoGain.gain.value = 0.0;
            
            echoFilter = audioContext.createBiquadFilter();
            echoFilter.type = 'lowpass';
            echoFilter.frequency.value = 400;
            echoFilter.Q.value = 1.5;
            
            echoTone = audioContext.createOscillator();
            echoTone.type = 'sine';
            echoTone.frequency.value = midiToFreq(musicalSettings.rootNote - 5);  // Perfect fifth, one octave below
            
            echoTone.connect(echoFilter);
            echoFilter.connect(echoGain);
            echoGain.connect(convolver);
            echoTone.start();
            
            audioEnabled = true;
        }
        
        /**
         * QUANTIZE PITCH FROM MOUSE POSITION (COLOR-SPECIFIC)
         * This function converts cursor Y position into a musical note frequency
         * Each color uses its own scale for variety!
         * 
         * HOW IT WORKS:
         * 1. Y position maps to a range of octaves (set by musicalSettings.octaveRange)
         * 2. We calculate a continuous frequency across that range
         * 3. We quantize it to the nearest note in the SELECTED COLOR'S scale
         * 4. Result: cursor movement = musical melody, different for each color!
         * 
         * @param {number} mouseYPos - Cursor Y position (0 at top, 1 at bottom)
         * @returns {number} - Quantized frequency in Hz
         */
        function quantizePitch(mouseYPos) {
            /*
             * Map Y position to MIDI note range:
             * - Top of screen (y=0) = high notes
             * - Bottom of screen (y=1) = low notes
             * - Range spans musicalSettings.octaveRange octaves (3 by default)
             */
            const octaves = musicalSettings.octaveRange;
            const lowestNote = musicalSettings.rootNote - 12;  // One octave below root
            const highestNote = lowestNote + (octaves * 12);   // Three octaves up
            
            // Invert Y so top = high pitch, bottom = low pitch
            const normalizedY = 1 - mouseYPos;
            
            // Calculate the raw MIDI note (can be fractional, like 62.5)
            const rawMidiNote = lowestNote + (normalizedY * (highestNote - lowestNote));
            
            // Convert to frequency
            const rawFreq = midiToFreq(rawMidiNote);
            
            // Get the scale for the currently selected color (or default to pentatonic)
            let scaleToUse = musicalSettings.scale;  // Default
            if (selectedColorIndex >= 0 && selectedColorIndex < colorVoices.length) {
                scaleToUse = colorVoices[selectedColorIndex].scale || musicalSettings.scale;
            }
            
            // Quantize to the color-specific scale
            const quantizedFreq = quantizeToScale(rawFreq, scaleToUse, musicalSettings.rootNote);
            
            return quantizedFreq;
        }

        // ===== TEXTURE MODE SOUND GENERATORS =====
        /*
         * Non-pitched texture sounds inspired by Oramics
         * Create varied sonic textures beyond musical pitches
         */
        
        /**
         * Generate noise sweep sounds (wind, ocean, static)
         * Filtered noise with sweeping frequency
         */
        function generateNoiseSweep(x, y, intensity) {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const duration = 0.5 + (1.0 - currentPaintingVelocity) * 2.0; // 0.5s to 2.5s
            
            // Create noise
            const bufferSize = audioContext.sampleRate * duration;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            
            // Generate noise with varying character based on position
            const noiseType = y; // 0.0-1.0 determines noise color
            for (let i = 0; i < bufferSize; i++) {
                // Mix white and pink noise based on Y position
                data[i] = (Math.random() * 2 - 1) * (0.3 + noiseType * 0.7);
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            
            // Sweeping filter
            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            const startFreq = 200 + y * 3000; // Y position determines sweep range
            const endFreq = startFreq + (x - 0.5) * 2000; // X position determines sweep direction
            filter.frequency.value = startFreq;
            filter.frequency.linearRampToValueAtTime(endFreq, now + duration);
            filter.Q.value = 2 + gestureCurvature * 8; // Curvature affects resonance
            
            const env = audioContext.createGain();
            const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5);
            const volume = 0.05 * intensity * (0.6 + velocityBoost * 0.4); // Reduced from 0.08 to 0.05
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(volume, now + 0.02);
            env.gain.linearRampToValueAtTime(volume * 0.7, now + duration * 0.3);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6));
            
            noise.connect(filter);
            filter.connect(env);
            env.connect(panner);
            panner.connect(masterGain);
            panner.connect(convolver);
            
            noise.start(now);
            noise.stop(now + duration);
            
            console.log('💨 Noise sweep:', startFreq.toFixed(0), '→', endFreq.toFixed(0), 'Hz');
        }
        
        /**
         * Generate percussive hit sounds (clicks, thuds, snaps)
         * Short, sharp transient sounds
         */
        function generatePercussiveHit(x, y, intensity) {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            
            // Y position determines hit type
            const hitType = y;
            let duration, freq, noiseAmount, attack, decay;
            
            if (hitType > 0.66) {
                // High click/snap
                duration = 0.02 + gestureCurvature * 0.03;
                freq = 2000 + x * 3000;
                noiseAmount = 0.7;
                attack = 0.001;
                decay = 0.015;
            } else if (hitType > 0.33) {
                // Mid thud
                duration = 0.08 + gestureCurvature * 0.05;
                freq = 150 + x * 300;
                noiseAmount = 0.4;
                attack = 0.002;
                decay = 0.06;
            } else {
                // Low thump
                duration = 0.15 + gestureCurvature * 0.1;
                freq = 40 + x * 100;
                noiseAmount = 0.2;
                attack = 0.003;
                decay = 0.12;
            }
            
            // Tonal component
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;
            osc.frequency.exponentialRampToValueAtTime(freq * 0.5, now + duration);
            
            // Noise component
            const bufferSize = audioContext.sampleRate * duration;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * noiseAmount;
            }
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = freq * 2;
            noiseFilter.Q.value = 5;
            
            const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5);
            const volume = 0.09 * intensity * (0.6 + velocityBoost * 0.4); // Reduced from 0.15 to 0.09
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(volume, now + attack);
            env.gain.exponentialRampToValueAtTime(0.001, now + decay);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6));
            
            osc.connect(env);
            noise.connect(noiseFilter);
            noiseFilter.connect(env);
            env.connect(panner);
            panner.connect(masterGain);
            
            osc.start(now);
            noise.start(now);
            osc.stop(now + duration);
            noise.stop(now + duration);
            
            console.log('🥁 Percussive hit:', hitType > 0.66 ? 'click' : hitType > 0.33 ? 'thud' : 'thump');
        }
        
        /**
         * Generate granular textures (sand, rain, crackling)
         * Many tiny sound grains creating texture
         */
        function generateGranularTexture(x, y, intensity) {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const duration = 0.3 + (1.0 - currentPaintingVelocity) * 1.0;
            
            // Number of grains based on velocity and curvature
            const grainCount = Math.floor(15 + currentPaintingVelocity * 35 + gestureCurvature * 20);
            const grainDuration = 0.01 + y * 0.04; // Y position affects grain length
            
            for (let i = 0; i < grainCount; i++) {
                const grainDelay = (i / grainCount) * duration * 0.9;
                const grainFreq = 200 + Math.random() * 2000 + x * 1000; // X position affects pitch range
                
                const grainOsc = audioContext.createOscillator();
                grainOsc.type = Math.random() > 0.5 ? 'sine' : 'triangle';
                grainOsc.frequency.value = grainFreq;
                
                const grainFilter = audioContext.createBiquadFilter();
                grainFilter.type = 'bandpass';
                grainFilter.frequency.value = grainFreq * (1 + Math.random() * 0.5);
                grainFilter.Q.value = 2 + Math.random() * 4;
                
                const grainEnv = audioContext.createGain();
                const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5);
                const grainVol = 0.012 * intensity * (0.6 + velocityBoost * 0.4) * (0.3 + Math.random() * 0.7); // Reduced from 0.02 to 0.012
                
                grainEnv.gain.value = 0;
                grainEnv.gain.setValueAtTime(0, now + grainDelay);
                grainEnv.gain.linearRampToValueAtTime(grainVol, now + grainDelay + 0.002);
                grainEnv.gain.exponentialRampToValueAtTime(0.001, now + grainDelay + grainDuration);
                
                const panner = audioContext.createStereoPanner();
                const panOffset = (Math.random() - 0.5) * 0.4;
                panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6 + panOffset));
                
                grainOsc.connect(grainFilter);
                grainFilter.connect(grainEnv);
                grainEnv.connect(panner);
                panner.connect(masterGain);
                panner.connect(convolver);
                
                grainOsc.start(now + grainDelay);
                grainOsc.stop(now + grainDelay + grainDuration);
            }
            
            console.log('✨ Granular texture:', grainCount, 'grains');
        }
        
        /**
         * Generate industrial sounds (metal scrapes, machinery)
         * Complex modulated noise with metallic character
         */
        function generateIndustrialSound(x, y, intensity) {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const duration = 0.4 + (1.0 - currentPaintingVelocity) * 1.5;
            
            // Multiple noise sources for complexity
            const numLayers = 3;
            
            for (let layer = 0; layer < numLayers; layer++) {
                // Create noise buffer
                const bufferSize = audioContext.sampleRate * duration;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1);
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                
                // Metallic resonant filter
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                const baseFreq = 100 + layer * 400 + y * 800; // Y position affects frequency range
                const endFreq = baseFreq + (x - 0.5) * 600 + Math.sin(layer * 2) * 200; // X affects modulation
                filter.frequency.value = baseFreq;
                filter.frequency.linearRampToValueAtTime(endFreq, now + duration * 0.6);
                filter.frequency.linearRampToValueAtTime(baseFreq * 0.8, now + duration);
                filter.Q.value = 8 + gestureCurvature * 12; // High resonance for metallic sound
                
                // Distortion for harshness
                const distortion = audioContext.createWaveShaper();
                const curve = new Float32Array(256);
                const amount = 2 + intensity * 3;
                for (let i = 0; i < 256; i++) {
                    const x = (i / 128) - 1;
                    curve[i] = Math.tanh(x * amount);
                }
                distortion.curve = curve;
                
                const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5);
                const volume = (0.025 + layer * 0.012) * intensity * (0.6 + velocityBoost * 0.4); // Reduced from 0.04/0.02 to 0.025/0.012
                
                const env = audioContext.createGain();
                env.gain.value = 0;
                env.gain.linearRampToValueAtTime(volume, now + 0.01 + layer * 0.02);
                env.gain.linearRampToValueAtTime(volume * 0.5, now + duration * 0.4);
                env.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                const panner = audioContext.createStereoPanner();
                const panOffset = (layer - 1) * 0.3; // Spread layers across stereo field
                panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6 + panOffset));
                
                noise.connect(filter);
                filter.connect(distortion);
                distortion.connect(env);
                env.connect(panner);
                panner.connect(masterGain);
                
                noise.start(now);
                noise.stop(now + duration);
            }
            
            console.log('🏭 Industrial sound:', y.toFixed(2), 'position');
        }
        
        /**
         * Main texture dispatcher - routes to appropriate texture generator
         */
        function triggerTextureSound(x, y, intensity) {
            if (!audioContext) return;
            
            // Y position determines texture type (0.0 = bottom, 1.0 = top)
            if (y >= 0.75) {
                // Top 25%: Noise sweeps
                generateNoiseSweep(x, y, intensity);
            } else if (y >= 0.5) {
                // Upper-middle 25%: Percussive hits
                generatePercussiveHit(x, y, intensity);
            } else if (y >= 0.25) {
                // Lower-middle 25%: Granular textures
                generateGranularTexture(x, y, intensity);
            } else {
                // Bottom 25%: Industrial sounds
                generateIndustrialSound(x, y, intensity);
            }
        }
        
        // ===== TEXTURE MODE 2 SOUND GENERATORS (ELECTRONIC/SYNTHETIC) =====
        /*
         * Electronic and synthetic textures inspired by early electronic music
         * FM synthesis, ring modulation, bit-crushing, vocoder-like effects
         */
        
        /**
         * Generate FM Bell sounds (Frequency Modulation)
         * Metallic, bell-like tones with complex harmonics
         */
        function generateFMBell(x, y, intensity) {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const duration = 0.8 + (1.0 - currentPaintingVelocity) * 2.0;
            
            // Carrier frequency (base pitch)
            const carrierFreq = 200 + y * 1500 + x * 500;
            
            // Modulator frequency (creates the metallic timbre)
            const modRatio = 2.1 + gestureCurvature * 3; // Curvature affects inharmonicity
            const modFreq = carrierFreq * modRatio;
            
            // Create carrier and modulator
            const carrier = audioContext.createOscillator();
            carrier.frequency.value = carrierFreq;
            
            const modulator = audioContext.createOscillator();
            modulator.frequency.value = modFreq;
            
            // Modulation depth (how much the modulator affects carrier)
            const modDepth = audioContext.createGain();
            const depthAmount = 100 + x * 400; // X position affects brightness
            modDepth.gain.value = depthAmount;
            modDepth.gain.exponentialRampToValueAtTime(1, now + duration); // Decay over time
            
            // Connect modulator to carrier frequency
            modulator.connect(modDepth);
            modDepth.connect(carrier.frequency);
            
            // Bell envelope - quick attack, slow decay
            const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5);
            const volume = 0.07 * intensity * (0.6 + velocityBoost * 0.4); // Reduced from 0.12 to 0.07
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(volume, now + 0.005);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6));
            
            carrier.connect(env);
            env.connect(panner);
            panner.connect(masterGain);
            panner.connect(convolver);
            
            carrier.start(now);
            modulator.start(now);
            carrier.stop(now + duration);
            modulator.stop(now + duration);
            
            console.log('🔔 FM Bell:', carrierFreq.toFixed(0), 'Hz, ratio:', modRatio.toFixed(2));
        }
        
        /**
         * Generate Ring Modulation sounds
         * Alien, robotic, inharmonic tones
         */
        function generateRingMod(x, y, intensity) {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const duration = 0.4 + (1.0 - currentPaintingVelocity) * 1.0;
            
            // Two oscillators for ring modulation
            const osc1Freq = 150 + y * 600;
            const osc2Freq = 200 + x * 800;
            
            const osc1 = audioContext.createOscillator();
            osc1.type = 'sine';
            osc1.frequency.value = osc1Freq;
            
            const osc2 = audioContext.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = osc2Freq;
            
            // Ring mod = multiply two signals (using gain as multiplier)
            const ringMod = audioContext.createGain();
            ringMod.gain.value = 0; // Starts at 0
            
            // Osc2 modulates the gain (ring modulation effect)
            osc2.connect(ringMod.gain);
            
            // Osc1 goes through the modulated gain
            osc1.connect(ringMod);
            
            // Add some filtering for character
            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 400 + y * 1000;
            filter.Q.value = 2 + gestureCurvature * 6;
            
            const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5);
            const volume = 0.09 * intensity * (0.6 + velocityBoost * 0.4); // Reduced from 0.15 to 0.09
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(volume, now + 0.01);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6));
            
            ringMod.connect(filter);
            filter.connect(env);
            env.connect(panner);
            panner.connect(masterGain);
            
            osc1.start(now);
            osc2.start(now);
            osc1.stop(now + duration);
            osc2.stop(now + duration);
            
            console.log('👽 Ring Mod:', osc1Freq.toFixed(0), '×', osc2Freq.toFixed(0), 'Hz');
        }
        
        /**
         * Generate Bit-Crushed Digital sounds
         * 8-bit video game glitches and artifacts
         */
        function generateBitCrush(x, y, intensity) {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const duration = 0.3 + (1.0 - currentPaintingVelocity) * 0.8;
            
            // Base oscillator
            const freq = 100 + y * 800 + Math.random() * 200;
            const osc = audioContext.createOscillator();
            osc.type = 'square'; // Square wave for digital character
            osc.frequency.value = freq;
            
            // Bit crushing via waveshaper
            const bitCrusher = audioContext.createWaveShaper();
            const bits = Math.floor(2 + (1 - y) * 6); // Y position = bit depth (2-8 bits)
            const steps = Math.pow(2, bits);
            const curve = new Float32Array(512);
            
            for (let i = 0; i < 512; i++) {
                const x = (i / 256) - 1;
                const crushed = Math.round(x * steps) / steps;
                curve[i] = crushed;
            }
            bitCrusher.curve = curve;
            
            // Sample rate reduction effect (via rapid modulation)
            const sampleRateHz = 4000 + x * 12000; // X position affects sample rate
            const tremolo = audioContext.createOscillator();
            tremolo.frequency.value = sampleRateHz;
            tremolo.type = 'square';
            
            const tremoloGain = audioContext.createGain();
            tremoloGain.gain.value = 0.5;
            
            tremolo.connect(tremoloGain);
            
            const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5);
            const volume = 0.06 * intensity * (0.6 + velocityBoost * 0.4); // Reduced from 0.1 to 0.06
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(volume, now + 0.005);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6));
            
            osc.connect(bitCrusher);
            bitCrusher.connect(env);
            env.connect(panner);
            panner.connect(masterGain);
            
            osc.start(now);
            tremolo.start(now);
            osc.stop(now + duration);
            tremolo.stop(now + duration);
            
            console.log('🎮 Bit-Crush:', bits, 'bits @', sampleRateHz.toFixed(0), 'Hz');
        }
        
        /**
         * Generate Vocoder-like sounds
         * Synthetic speech-like textures
         */
        function generateVocoder(x, y, intensity) {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const duration = 0.5 + (1.0 - currentPaintingVelocity) * 1.5;
            
            // Noise source (like vocal excitation)
            const bufferSize = audioContext.sampleRate * duration;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            
            // Multiple formant filters (vocal-like resonances)
            const numFormants = 3;
            const formantFilters = [];
            
            for (let i = 0; i < numFormants; i++) {
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                
                // Formant frequencies based on Y position
                const formantBase = [300, 1000, 2500]; // Typical vocal formants
                const formantFreq = formantBase[i] + y * 500 + x * 300;
                filter.frequency.value = formantFreq;
                filter.Q.value = 8 + gestureCurvature * 8; // High Q for vocal quality
                
                formantFilters.push(filter);
            }
            
            // Create parallel routing for formants
            const merger = audioContext.createChannelMerger(numFormants);
            const splitter = audioContext.createChannelSplitter(numFormants);
            
            formantFilters.forEach((filter, i) => {
                noise.connect(filter);
                filter.connect(merger, 0, i);
            });
            
            const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5);
            const volume = 0.05 * intensity * (0.6 + velocityBoost * 0.4); // Reduced from 0.08 to 0.05
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(volume, now + 0.02);
            env.gain.linearRampToValueAtTime(volume * 0.7, now + duration * 0.5);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6));
            
            merger.connect(env);
            env.connect(panner);
            panner.connect(masterGain);
            panner.connect(convolver);
            
            noise.start(now);
            noise.stop(now + duration);
            
            console.log('🗣️ Vocoder:', numFormants, 'formants');
        }
        
        /**
         * Main texture 2 dispatcher - routes to appropriate electronic texture generator
         */
        function triggerTextureSound2(x, y, intensity) {
            if (!audioContext) return;
            
            // Y position determines texture type (0.0 = bottom, 1.0 = top)
            if (y >= 0.75) {
                // Top 25%: FM Bells
                generateFMBell(x, y, intensity);
            } else if (y >= 0.5) {
                // Upper-middle 25%: Ring Modulation
                generateRingMod(x, y, intensity);
            } else if (y >= 0.25) {
                // Lower-middle 25%: Bit-Crushed Digital
                generateBitCrush(x, y, intensity);
            } else {
                // Bottom 25%: Vocoder-like
                generateVocoder(x, y, intensity);
            }
        }

        // ===== RHYTHMIC PATTERN EFFECT PROCESSORS =====
        
        /**
         * Apply arpeggiator to pitched sounds (musical mode only)
         * Cycles through a note pattern, transposing each trigger
         */
        function applyArpeggiator(freq) {
            if (!oramicsEffects.arpeggiator.active) return freq;
            
            // Calculate semitone offset from pattern
            const semitoneOffset = arpPattern[arpNoteIndex % arpPattern.length];
            
            // Advance to next note in pattern
            arpNoteIndex++;
            
            // Apply transposition (multiply by 2^(semitones/12))
            const transposedFreq = freq * Math.pow(2, semitoneOffset / 12);
            
            console.log('⟨⟩ Arp:', arpNoteIndex % arpPattern.length, '+', semitoneOffset, 'semitones');
            
            return transposedFreq;
        }
        
        /**
         * Stutter effect - stores and replays recent sounds
         */
        function processStutter(x, y, intensity, triggerFunc) {
            if (!oramicsEffects.stutter.active) return;
            
            const now = Date.now();
            
            // Store this sound event
            stutterBuffer.push({ x, y, intensity, time: now });
            
            // Keep only last 5 events
            if (stutterBuffer.length > 5) {
                stutterBuffer.shift();
            }
            
            // Replay stutters at intervals
            if (now - lastStutterTime > STUTTER_INTERVAL && stutterBuffer.length > 0) {
                // Pick a random recent sound to repeat
                const randomEvent = stutterBuffer[Math.floor(Math.random() * stutterBuffer.length)];
                
                // Retrigger it with slight variation
                const varX = randomEvent.x + (Math.random() - 0.5) * 0.05;
                const varY = randomEvent.y + (Math.random() - 0.5) * 0.05;
                
                triggerFunc(varX, varY, randomEvent.intensity * 0.7); // Quieter repeat
                
                lastStutterTime = now;
                console.log('⧈ Stutter repeat');
            }
        }
        
        /**
         * Polyrhythm effect - adds additional rhythm layers
         * Triggers extra notes at odd divisions
         */
        function processPolyrhythm(x, y, intensity, triggerFunc) {
            if (!oramicsEffects.polyrhythm.active) return;
            
            // Schedule polyrhythmic echoes at different subdivisions
            POLYRHYTHM_DIVISIONS.forEach((division, index) => {
                const delay = (musicalClock.bpm / 60) * 1000 / division; // ms per division
                
                setTimeout(() => {
                    // Slight spatial offset for each layer
                    const offsetX = x + (index - 1) * 0.1;
                    const offsetY = y + (Math.random() - 0.5) * 0.05;
                    
                    triggerFunc(offsetX, offsetY, intensity * 0.5); // Quieter echoes
                }, delay * (index + 1));
            });
            
            console.log('◈ Polyrhythm layers added');
        }

        // COLOR VOICE AUDIO TRIGGER
        function triggerColorVoice(voiceIndex, x, y, colorIntensity) {
            const voice = colorVoices[voiceIndex];
            const sound = voice.sound;
            const now = audioContext.currentTime;
            
            let baseFreq = quantizePitch(y) * sound.baseFreqMultiplier;
            
            // Apply arpeggiator if active
            baseFreq = applyArpeggiator(baseFreq);
            const visualFadeTime = 5.0 * voice.persistence;
            let soundRelease = visualFadeTime * 0.8;
            let attackTime = sound.attack;
            
            // ===== PAINTED ENVELOPE (ORAMICS) =====
            /*
             * When Painted Envelope is active, gesture shape controls sound evolution
             * Inspired by Daphne Oram's Oramics technique
             * 
             * GESTURE METRICS:
             * - gestureAvgVelocity: How fast you're painting (0-1+)
             * - gesturePathLength: How long the stroke is (0-1+)
             * - gestureDuration: How long you've been painting (ms)
             * 
             * SOUND PARAMETERS:
             * - Fast stroke = quick attack, short release (percussive)
             * - Slow stroke = slow attack, long release (pad-like)
             * - Short stroke = tight, punchy sound
             * - Long stroke = sustained, evolving sound
             */
            if (oramicsEffects.paintedEnvelope.active && isGestureActive) {
                const gestureDuration = (Date.now() - gestureStartTime) / 1000; // in seconds
                
                // Map velocity to envelope speed - EXTREMELY DRAMATIC RANGE
                // Fast velocity (>0.5) = INSTANT attack (0.001s), VERY SHORT release (0.05s) - SUPER PERCUSSIVE
                // Slow velocity (<0.1) = VERY SLOW attack (2.0s), EXTREMELY LONG release (8.0s) - AMBIENT PAD
                const velocityNorm = Math.min(gestureAvgVelocity / 0.5, 1.0);
                attackTime = 0.001 + (1.0 - velocityNorm) * 2.0; // 0.001s to 2.0s (WIDER!)
                soundRelease = 0.05 + (1.0 - velocityNorm) * 7.95; // 0.05s to 8.0s (MUCH LONGER!)
                
                // Path length affects sustain EXTREMELY DRAMATICALLY
                // Short stroke = quick fade
                // Long stroke = very sustained sound
                const pathLengthBoost = Math.min(gesturePathLength / 0.25, 4.0); // Up to 4x boost (wider!)
                soundRelease *= pathLengthBoost;
                
                // Duration affects overall envelope curve MUCH MORE
                // Longer gestures = extremely sustained sounds
                const durationBoost = Math.min(gestureDuration / 1.0, 3.5); // Up to 3.5x boost (wider!)
                soundRelease *= durationBoost;
            }
            
            const duration = attackTime + soundRelease;
            
            const safeIntensity = Math.max(0, Math.min(colorIntensity || 0, 1.0));
            let baseVolume = 0.04 * Math.min(safeIntensity * 3, 1.0);
            
            // ===== VELOCITY RESPONSIVE VOLUME & BRIGHTNESS =====
            /*
             * Faster painting = louder sound and brighter filter
             * Makes the instrument feel more dynamic and expressive
             */
            // Normalize velocity to 0-1 range (0.5 is moderate speed, 2.0+ is very fast)
            const velocityBoost = Math.min(currentPaintingVelocity / 0.8, 1.5); // 0 to 1.5x multiplier
            baseVolume *= (0.6 + velocityBoost * 0.4); // 60% base + up to 60% velocity boost = 0.6x to 1.2x
            
            // Store velocity for filter brightness adjustment (will be used after filter creation)
            const filterBrightnessBoost = 1.0 + (velocityBoost * 0.8); // 1.0x to 1.8x brighter
            
            // ===== CURVATURE RESPONSIVE TIMBRE =====
            /*
             * Curved gestures add subtle harmonic variation
             * Straight lines = pure tone, Curves = richer harmonics
             */
            const curvatureDetuneAmount = gestureCurvature * 8; // 0 to 8 cents detune (subtle)
            const curvatureFilterMod = gestureCurvature * 0.15; // 0 to 15% filter modulation (subtle)
            
            if (!isFinite(baseVolume) || !isFinite(duration) || baseVolume <= 0) {
                return;
            }
            
            const osc = audioContext.createOscillator();
            osc.type = sound.waveform;
            osc.frequency.value = baseFreq;
            
            // ===== DRAWN WAVEFORMS (ORAMICS) =====
            /*
             * When Drawn Waveforms is active, use the visual pattern to create
             * a custom waveform that replaces the basic oscillator
             * This is the literal Oramics technique!
             */
            if (oramicsEffects.drawnWaveforms.active && visualWaveformBuffer) {
                try {
                    // Use visual data as Fourier coefficients
                    // EXTREME MODE: More harmonics, stronger visual influence!
                    const harmonicCount = Math.min(64, visualWaveformBuffer.length); // 2x more harmonics!
                    const real = new Float32Array(harmonicCount);
                    const imag = new Float32Array(harmonicCount);
                    
                    // Map visual brightness to harmonic amplitudes - EXTREME!
                    for (let i = 0; i < harmonicCount; i++) {
                        const visualValue = visualWaveformBuffer[Math.floor((i / harmonicCount) * visualWaveformBuffer.length)];
                        // EXTREME: Even stronger visual influence with added harmonics
                        const harmonicBoost = 1.0 + (i * 0.02); // Higher harmonics get boosted more
                        real[i] = visualValue * 1.2 * harmonicBoost; // MUCH stronger!
                        imag[i] = visualValue * 1.2 * harmonicBoost; // MUCH stronger!
                    }
                    
                    const periodicWave = audioContext.createPeriodicWave(real, imag);
                    osc.setPeriodicWave(periodicWave);
                    console.log('✓ EXTREME Visual waveform applied - 64 harmonics!');
                } catch (e) {
                    console.log('✗ Could not set visual waveform:', e);
                }
            }
            
            if (sound.detune) {
                osc.detune.value = (Math.random() - 0.5) * sound.detune + curvatureDetuneAmount;
            } else if (curvatureDetuneAmount > 0) {
                // Apply curvature detune even if sound doesn't have natural detune
                osc.detune.value = curvatureDetuneAmount;
            }
            
            if (sound.useModulation) {
                const lfo = audioContext.createOscillator();
                lfo.frequency.value = sound.modulationRate;
                const lfoGain = audioContext.createGain();
                lfoGain.gain.value = sound.modulationDepth;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start(now);
                lfo.stop(now + duration);
            }
            
            // SUB BASS for earthy rumble (brown)
            let subBass = null;
            let subBassEnv = null;
            if (sound.useSubBass) {
                subBass = audioContext.createOscillator();
                subBass.type = 'sine';
                subBass.frequency.value = baseFreq * sound.subBassFreq;
                
                subBassEnv = audioContext.createGain();
                subBassEnv.gain.value = 0;
                subBassEnv.gain.linearRampToValueAtTime(baseVolume * 0.8, now + 0.1);
                subBassEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                subBass.connect(subBassEnv);
            }
            
            // CRACKLE generator for organic texture (brown)
            let crackleNodes = [];
            if (sound.useCrackle) {
                const numCrackles = sound.crackleRate || 8;
                for (let i = 0; i < numCrackles; i++) {
                    const crackleDelay = Math.random() * duration * 0.9;
                    const crackleOsc = audioContext.createOscillator();
                    crackleOsc.type = Math.random() > 0.5 ? 'square' : 'sawtooth';
                    crackleOsc.frequency.value = 800 + Math.random() * 4000;
                    
                    const crackleEnv = audioContext.createGain();
                    crackleEnv.gain.value = 0;
                    crackleEnv.gain.setValueAtTime(0, now + crackleDelay);
                    const crackleVol = baseVolume * sound.crackleIntensity * (0.3 + Math.random() * 0.7);
                    crackleEnv.gain.linearRampToValueAtTime(crackleVol, now + crackleDelay + 0.002);
                    crackleEnv.gain.exponentialRampToValueAtTime(0.001, now + crackleDelay + 0.015);
                    
                    crackleOsc.connect(crackleEnv);
                    crackleNodes.push({ osc: crackleOsc, env: crackleEnv });
                }
            }
            
            // RUMBLE - chaotic low frequency movement (brown)
            let rumbleOsc = null;
            let rumbleEnv = null;
            if (sound.useRumble) {
                rumbleOsc = audioContext.createOscillator();
                rumbleOsc.type = 'sawtooth';
                rumbleOsc.frequency.value = baseFreq * 0.15;
                
                // Chaotic modulation
                const rumbleMod = audioContext.createOscillator();
                rumbleMod.frequency.value = 2.3;
                const rumbleModGain = audioContext.createGain();
                rumbleModGain.gain.value = baseFreq * 0.08;
                rumbleMod.connect(rumbleModGain);
                rumbleModGain.connect(rumbleOsc.frequency);
                rumbleMod.start(now);
                rumbleMod.stop(now + duration);
                
                rumbleEnv = audioContext.createGain();
                rumbleEnv.gain.value = 0;
                const rumbleVol = baseVolume * (sound.rumbleVolume || 0.6);
                rumbleEnv.gain.linearRampToValueAtTime(rumbleVol, now + 0.1);
                rumbleEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                rumbleOsc.connect(rumbleEnv);
            }
            
            // BAMBOO WIND CHIMES - hollow resonant tubes (green)
            let bambooNodes = [];
            if (sound.useBamboo && sound.bambooTubes) {
                const bambooVol = sound.bambooVolume || 0.7;
                sound.bambooTubes.forEach((ratio, i) => {
                    const bambooOsc = audioContext.createOscillator();
                    bambooOsc.type = 'triangle';  // Hollow sound
                    bambooOsc.frequency.value = baseFreq * ratio;
                    
                    // Quick strike, long resonance
                    const bambooEnv = audioContext.createGain();
                    bambooEnv.gain.value = 0;
                    const bambooAttackVol = baseVolume * bambooVol / (i * 0.3 + 1);
                    bambooEnv.gain.linearRampToValueAtTime(bambooAttackVol, now + 0.001);
                    bambooEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * sound.bambooDecay);
                    
                    bambooOsc.connect(bambooEnv);
                    bambooNodes.push({ osc: bambooOsc, env: bambooEnv });
                });
            }
            
            // HOLLOW RESONANCE - sub-frequency for bamboo tube effect (green)
            let hollowResonance = null;
            let hollowEnv = null;
            if (sound.useHollowResonance) {
                hollowResonance = audioContext.createOscillator();
                hollowResonance.type = 'sine';
                hollowResonance.frequency.value = baseFreq * sound.resonanceFreq;
                
                hollowEnv = audioContext.createGain();
                hollowEnv.gain.value = 0;
                hollowEnv.gain.linearRampToValueAtTime(baseVolume * 0.4, now + 0.005);
                hollowEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);
                
                hollowResonance.connect(hollowEnv);
            }
            
            // WIND NOISE - air rushing through bamboo (green)
            let windNoise = null;
            let windEnv = null;
            if (sound.useWindNoise) {
                const windBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
                const windData = windBuffer.getChannelData(0);
                for (let i = 0; i < windData.length; i++) {
                    windData[i] = (Math.random() * 2 - 1) * 0.5;
                }
                windNoise = audioContext.createBufferSource();
                windNoise.buffer = windBuffer;
                windNoise.loop = true;
                
                const windFilter = audioContext.createBiquadFilter();
                windFilter.type = 'highpass';
                windFilter.frequency.value = 2000;
                
                windEnv = audioContext.createGain();
                windEnv.gain.value = 0;
                windEnv.gain.linearRampToValueAtTime(baseVolume * sound.windIntensity, now + 0.02);
                windEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.3);
                
                windNoise.connect(windFilter);
                windFilter.connect(windEnv);
            }
            
            // METALLIC SHIMMER - high overtones (green)
            let shimmerNodes = [];
            if (sound.useMetallicShimmer) {
                const numShimmers = sound.shimmerCount || 6;
                for (let i = 0; i < numShimmers; i++) {
                    const shimmerDelay = Math.random() * duration * 0.7;
                    const shimmerOsc = audioContext.createOscillator();
                    shimmerOsc.type = 'sine';
                    shimmerOsc.frequency.value = baseFreq * (5 + Math.random() * 8);
                    
                    const shimmerEnv = audioContext.createGain();
                    shimmerEnv.gain.value = 0;
                    shimmerEnv.gain.setValueAtTime(0, now + shimmerDelay);
                    shimmerEnv.gain.linearRampToValueAtTime(baseVolume * 0.15, now + shimmerDelay + 0.005);
                    shimmerEnv.gain.exponentialRampToValueAtTime(0.001, now + shimmerDelay + 0.2);
                    
                    shimmerOsc.connect(shimmerEnv);
                    shimmerNodes.push({ osc: shimmerOsc, env: shimmerEnv });
                }
            }
            
            // ICE CRACKLE - brittle, fast pops (pink)
            let iceCrackleNodes = [];
            if (sound.useIceCrackle) {
                const numCrackles = sound.iceCrackleCount || 20;
                for (let i = 0; i < numCrackles; i++) {
                    const crackleDelay = Math.random() * duration * 0.95;
                    const crackleOsc = audioContext.createOscillator();
                    crackleOsc.type = 'square';  // Harsh brittle sound
                    crackleOsc.frequency.value = baseFreq * (8 + Math.random() * 12);
                    
                    const crackleEnv = audioContext.createGain();
                    crackleEnv.gain.value = 0;
                    const crackleVol = baseVolume * sound.crackleIntensity * (0.4 + Math.random() * 0.6);
                    crackleEnv.gain.setValueAtTime(0, now + crackleDelay);
                    crackleEnv.gain.linearRampToValueAtTime(crackleVol, now + crackleDelay + sound.crackleSpeed);
                    crackleEnv.gain.exponentialRampToValueAtTime(0.001, now + crackleDelay + sound.crackleSpeed + 0.03);
                    
                    crackleOsc.connect(crackleEnv);
                    iceCrackleNodes.push({ osc: crackleOsc, env: crackleEnv });
                }
            }
            
            // FROZEN RESONANCE - very high pitched layers (pink)
            let frozenResonanceNodes = [];
            if (sound.useFrozenResonance && sound.frozenPitches) {
                sound.frozenPitches.forEach((ratio, i) => {
                    const frozenOsc = audioContext.createOscillator();
                    frozenOsc.type = 'sine';
                    frozenOsc.frequency.value = baseFreq * ratio;
                    
                    const frozenEnv = audioContext.createGain();
                    frozenEnv.gain.value = 0;
                    const frozenVol = baseVolume * 0.3 / (i + 1);
                    frozenEnv.gain.linearRampToValueAtTime(frozenVol, now + 0.001);
                    frozenEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.6);
                    
                    frozenOsc.connect(frozenEnv);
                    frozenResonanceNodes.push({ osc: frozenOsc, env: frozenEnv });
                });
            }
            
            // GLASS SHATTER - scattered high frequency impacts (pink)
            let glassShatterNodes = [];
            if (sound.useGlassShatter) {
                const numShatters = sound.shatterDensity || 10;
                for (let i = 0; i < numShatters; i++) {
                    const shatterDelay = Math.random() * duration * 0.8;
                    const shatterOsc = audioContext.createOscillator();
                    shatterOsc.type = 'sine';
                    shatterOsc.frequency.value = baseFreq * (10 + Math.random() * 15);
                    
                    const shatterEnv = audioContext.createGain();
                    shatterEnv.gain.value = 0;
                    shatterEnv.gain.setValueAtTime(0, now + shatterDelay);
                    shatterEnv.gain.linearRampToValueAtTime(baseVolume * 0.4, now + shatterDelay + 0.001);
                    shatterEnv.gain.exponentialRampToValueAtTime(0.001, now + shatterDelay + 0.05);
                    
                    shatterOsc.connect(shatterEnv);
                    glassShatterNodes.push({ osc: shatterOsc, env: shatterEnv });
                }
            }
            
            // HIGH SHIMMER - ultra-high frequency sparkle (pink)
            let highShimmer = null;
            let highShimmerEnv = null;
            if (sound.useHighShimmer) {
                highShimmer = audioContext.createOscillator();
                highShimmer.type = 'sine';
                highShimmer.frequency.value = baseFreq * sound.shimmerFreq;
                
                highShimmerEnv = audioContext.createGain();
                highShimmerEnv.gain.value = 0;
                highShimmerEnv.gain.linearRampToValueAtTime(baseVolume * 0.25, now + 0.005);
                highShimmerEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.4);
                
                highShimmer.connect(highShimmerEnv);
            }
            
            // METAL GRIND - modulated grinding texture (red)
            let metalGrindOsc = null;
            let metalGrindEnv = null;
            if (sound.useMetalGrind) {
                metalGrindOsc = audioContext.createOscillator();
                metalGrindOsc.type = 'sawtooth';
                metalGrindOsc.frequency.value = baseFreq * 0.5;
                
                // Fast modulation for grinding texture
                const grindMod = audioContext.createOscillator();
                grindMod.frequency.value = sound.grindModulation;
                const grindModGain = audioContext.createGain();
                grindModGain.gain.value = baseFreq * 0.3;
                grindMod.connect(grindModGain);
                grindModGain.connect(metalGrindOsc.frequency);
                grindMod.start(now);
                grindMod.stop(now + duration);
                
                metalGrindEnv = audioContext.createGain();
                metalGrindEnv.gain.value = 0;
                const grindVol = baseVolume * sound.grindIntensity;
                metalGrindEnv.gain.linearRampToValueAtTime(grindVol, now + 0.01);
                metalGrindEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                metalGrindOsc.connect(metalGrindEnv);
            }
            
            // METAL HITS - percussive industrial impacts (red)
            let metalHitNodes = [];
            if (sound.useMetalHits) {
                const numHits = sound.metalHitCount || 12;
                for (let i = 0; i < numHits; i++) {
                    const hitDelay = Math.random() * duration * 0.9;
                    const hitOsc = audioContext.createOscillator();
                    hitOsc.type = 'square';
                    hitOsc.frequency.value = baseFreq * (0.5 + Math.random() * 1.5);
                    
                    const hitEnv = audioContext.createGain();
                    hitEnv.gain.value = 0;
                    const hitVol = baseVolume * sound.metalHitVolume * (0.6 + Math.random() * 0.4);
                    hitEnv.gain.setValueAtTime(0, now + hitDelay);
                    hitEnv.gain.linearRampToValueAtTime(hitVol, now + hitDelay + 0.002);
                    hitEnv.gain.exponentialRampToValueAtTime(0.001, now + hitDelay + 0.08);
                    
                    hitOsc.connect(hitEnv);
                    metalHitNodes.push({ osc: hitOsc, env: hitEnv });
                }
            }
            
            // GRIND NOISE - harsh industrial noise layer (red)
            let grindNoise = null;
            let grindNoiseEnv = null;
            if (sound.useGrindNoise) {
                const grindBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
                const grindData = grindBuffer.getChannelData(0);
                for (let i = 0; i < grindData.length; i++) {
                    grindData[i] = (Math.random() * 2 - 1) * 0.8;
                }
                grindNoise = audioContext.createBufferSource();
                grindNoise.buffer = grindBuffer;
                grindNoise.loop = true;
                
                const grindFilter = audioContext.createBiquadFilter();
                grindFilter.type = 'bandpass';
                grindFilter.frequency.value = 400;
                grindFilter.Q.value = 3;
                
                grindNoiseEnv = audioContext.createGain();
                grindNoiseEnv.gain.value = 0;
                const grindNoiseVol = baseVolume * sound.grindNoiseRatio;
                grindNoiseEnv.gain.linearRampToValueAtTime(grindNoiseVol, now + 0.02);
                grindNoiseEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                grindNoise.connect(grindFilter);
                grindFilter.connect(grindNoiseEnv);
            }
            
            // LOW RUMBLE - deep machinery rumble (red)
            let lowRumble = null;
            let lowRumbleEnv = null;
            if (sound.useLowRumble) {
                lowRumble = audioContext.createOscillator();
                lowRumble.type = 'sawtooth';
                lowRumble.frequency.value = baseFreq * sound.rumbleFreq;
                
                lowRumbleEnv = audioContext.createGain();
                lowRumbleEnv.gain.value = 0;
                lowRumbleEnv.gain.linearRampToValueAtTime(baseVolume * 0.7, now + 0.05);
                lowRumbleEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                lowRumble.connect(lowRumbleEnv);
            }
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(baseVolume, now + attackTime);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            let noiseNode = null;
            let noiseEnv = null;
            if (sound.useNoise || sound.heavyNoise) {
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = Math.random() * 2 - 1;
                }
                noiseNode = audioContext.createBufferSource();
                noiseNode.buffer = noiseBuffer;
                noiseNode.loop = true;
                
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = sound.heavyNoise ? 'lowpass' : 'bandpass';
                noiseFilter.frequency.value = sound.heavyNoise ? 800 : sound.filterFreq;
                noiseFilter.Q.value = sound.heavyNoise ? 1.5 : 2;
                
                noiseEnv = audioContext.createGain();
                noiseEnv.gain.value = 0;
                const noiseRatio = sound.noiseRatio || 0.4;
                const noiseVol = baseVolume * noiseRatio;
                noiseEnv.gain.linearRampToValueAtTime(noiseVol, now + sound.attack);
                noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                noiseNode.connect(noiseFilter);
                noiseFilter.connect(noiseEnv);
            }
            
            // HIGH SHIMMER layer (pink)
            let shimmerOsc = null;
            let shimmerEnv = null;
            if (sound.highShimmer) {
                shimmerOsc = audioContext.createOscillator();
                shimmerOsc.type = 'sine';
                shimmerOsc.frequency.value = baseFreq * 12;
                
                shimmerEnv = audioContext.createGain();
                shimmerEnv.gain.value = 0;
                shimmerEnv.gain.linearRampToValueAtTime(baseVolume * 0.08, now + 0.02);
                shimmerEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);
                
                shimmerOsc.connect(shimmerEnv);
            }
            
            // HEAVY DISTORTION (brown) - extreme overdrive
            let heavyDistortion = null;
            if (sound.useHeavyDistortion) {
                heavyDistortion = audioContext.createWaveShaper();
                const curve = new Float32Array(512);
                const drive = sound.distortionDrive || 5.0;
                for (let i = 0; i < 512; i++) {
                    const x = (i * 2) / 512 - 1;
                    // Extreme hard clipping with asymmetry for grit
                    const driven = x * drive;
                    if (driven > 1) {
                        curve[i] = 0.95 + Math.random() * 0.05;  // Hard clip with noise
                    } else if (driven < -1) {
                        curve[i] = -0.95 - Math.random() * 0.05;
                    } else {
                        // Aggressive curve before clipping
                        curve[i] = Math.tanh(driven * 1.5) * 0.9;
                    }
                }
                heavyDistortion.curve = curve;
                heavyDistortion.oversample = '2x';
            }
            
            // BIT CRUSHER (brown) - digital degradation
            let bitCrusher = null;
            if (sound.useBitCrusher) {
                bitCrusher = audioContext.createWaveShaper();
                const curve = new Float32Array(512);
                const bits = sound.bitDepth || 4;
                const steps = Math.pow(2, bits);
                for (let i = 0; i < 512; i++) {
                    const x = (i * 2) / 512 - 1;
                    // Quantize to low bit depth
                    const step = Math.round(x * steps) / steps;
                    curve[i] = step;
                }
                bitCrusher.curve = curve;
            }
            
            // WAVESHAPER for distortion (red)
            let waveshaper = null;
            if (sound.useDistortion) {
                waveshaper = audioContext.createWaveShaper();
                const curve = new Float32Array(256);
                const amount = sound.distortionAmount;
                for (let i = 0; i < 256; i++) {
                    const x = (i / 128) - 1;
                    curve[i] = Math.tanh(x * (1 + amount * 10));
                }
                waveshaper.curve = curve;
                waveshaper.oversample = '2x';
            }
            
            const harmonics = [];
            for (let i = 1; i <= sound.harmonics; i++) {
                const harmOsc = audioContext.createOscillator();
                harmOsc.type = 'sine';
                
                const ratio = i + 1 + (Math.random() * 0.5);
                harmOsc.frequency.value = baseFreq * ratio;
                
                if (sound.detune) {
                    harmOsc.detune.value = (Math.random() - 0.5) * sound.detune * 0.5;
                }
                
                const harmEnv = audioContext.createGain();
                harmEnv.gain.value = 0;
                const harmAmp = baseVolume * 0.5 / (i + 1);
                harmEnv.gain.linearRampToValueAtTime(harmAmp, now + sound.attack);
                harmEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                harmOsc.connect(harmEnv);
                harmonics.push({ osc: harmOsc, env: harmEnv });
            }
            
            const filter = audioContext.createBiquadFilter();
            filter.type = sound.filterType;
            // Apply velocity brightness boost - faster painting = brighter filter
            filter.frequency.value = sound.filterFreq * filterBrightnessBoost;
            // Apply curvature modulation - curved gestures add subtle filter wobble
            filter.Q.value = sound.filterQ * (1.0 + curvatureFilterMod);
            
            // Animate filter with velocity-adjusted brightness
            filter.frequency.linearRampToValueAtTime(sound.filterFreq * 1.5 * filterBrightnessBoost, now + duration * 0.3);
            filter.frequency.linearRampToValueAtTime(sound.filterFreq * 0.8 * filterBrightnessBoost, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6)); // Slightly more pronounced panning
            
            const dryGain = audioContext.createGain();
            const wetGain = audioContext.createGain();
            dryGain.gain.value = 1 - (sound.reverbMix || 0.5);
            wetGain.gain.value = sound.reverbMix || 0.5;
            
            // Main oscillator routing
            osc.connect(env);
            
            // Route harmonics to filter
            harmonics.forEach(h => h.env.connect(filter));
            
            // Route env through distortion if present (red), otherwise to filter
            if (waveshaper) {
                env.connect(waveshaper);
                waveshaper.connect(filter);
            } else {
                env.connect(filter);
            }
            
            // Add all the texture layers to filter
            if (noiseEnv) noiseEnv.connect(filter);
            if (subBassEnv) subBassEnv.connect(filter);
            if (shimmerEnv) shimmerEnv.connect(filter);
            
            // Crackles (brown) - random organic pops  
            crackleNodes.forEach(node => node.env.connect(filter));
            
            // Rumble (brown) - chaotic low frequency
            if (rumbleEnv) rumbleEnv.connect(filter);
            
            // Bamboo wind chimes (green) - hollow resonant tubes
            bambooNodes.forEach(bamboo => bamboo.env.connect(filter));
            
            // Hollow resonance (green) - sub-frequency
            if (hollowEnv) hollowEnv.connect(filter);
            
            // Wind noise (green) - air rushing through bamboo
            if (windEnv) windEnv.connect(filter);
            
            // Metallic shimmer (green) - high overtones
            shimmerNodes.forEach(shimmer => shimmer.env.connect(filter));
            
            // Ice crackle (pink) - brittle pops
            iceCrackleNodes.forEach(ice => ice.env.connect(filter));
            
            // Frozen resonance (pink) - very high layers
            frozenResonanceNodes.forEach(frozen => frozen.env.connect(filter));
            
            // Glass shatter (pink) - scattered impacts
            glassShatterNodes.forEach(shatter => shatter.env.connect(filter));
            
            // High shimmer (pink) - ultra-high sparkle
            if (highShimmerEnv) highShimmerEnv.connect(filter);
            
            // Metal grind (red) - modulated grinding
            if (metalGrindEnv) metalGrindEnv.connect(filter);
            
            // Metal hits (red) - industrial impacts
            metalHitNodes.forEach(hit => hit.env.connect(filter));
            
            // Grind noise (red) - harsh industrial noise
            if (grindNoiseEnv) grindNoiseEnv.connect(filter);
            
            // Low rumble (red) - deep machinery
            if (lowRumbleEnv) lowRumbleEnv.connect(filter);
            
            // Chain distortion effects for brown
            if (heavyDistortion && bitCrusher) {
                filter.connect(heavyDistortion);
                heavyDistortion.connect(bitCrusher);
                bitCrusher.connect(panner);
            } else if (heavyDistortion) {
                filter.connect(heavyDistortion);
                heavyDistortion.connect(panner);
            } else if (bitCrusher) {
                filter.connect(bitCrusher);
                bitCrusher.connect(panner);
            } else {
                filter.connect(panner);
            }
            
            panner.connect(dryGain);
            panner.connect(wetGain);
            
            dryGain.connect(masterGain);
            wetGain.connect(convolver);
            
            // Start all oscillators
            osc.start(now);
            osc.stop(now + duration);
            
            if (noiseNode) {
                noiseNode.start(now);
                noiseNode.stop(now + duration);
            }
            if (subBass) {
                subBass.start(now);
                subBass.stop(now + duration);
            }
            if (shimmerOsc) {
                shimmerOsc.start(now);
                shimmerOsc.stop(now + duration);
            }
            
            harmonics.forEach(h => {
                h.osc.start(now);
                h.osc.stop(now + duration);
            });
            
            crackleNodes.forEach(node => {
                node.osc.start(now);
                node.osc.stop(now + duration);
            });
            
            if (rumbleOsc) {
                rumbleOsc.start(now);
                rumbleOsc.stop(now + duration);
            }
            
            // GREEN - Bamboo wind chimes
            bambooNodes.forEach(bamboo => {
                bamboo.osc.start(now);
                bamboo.osc.stop(now + duration);
            });
            
            if (hollowResonance) {
                hollowResonance.start(now);
                hollowResonance.stop(now + duration);
            }
            
            if (windNoise) {
                windNoise.start(now);
                windNoise.stop(now + duration);
            }
            
            shimmerNodes.forEach(shimmer => {
                shimmer.osc.start(now);
                shimmer.osc.stop(now + duration);
            });
            
            // PINK - Ice crystals
            iceCrackleNodes.forEach(ice => {
                ice.osc.start(now);
                ice.osc.stop(now + duration);
            });
            
            frozenResonanceNodes.forEach(frozen => {
                frozen.osc.start(now);
                frozen.osc.stop(now + duration);
            });
            
            glassShatterNodes.forEach(shatter => {
                shatter.osc.start(now);
                shatter.osc.stop(now + duration);
            });
            
            if (highShimmer) {
                highShimmer.start(now);
                highShimmer.stop(now + duration);
            }
            
            // RED - Industrial machinery
            if (metalGrindOsc) {
                metalGrindOsc.start(now);
                metalGrindOsc.stop(now + duration);
            }
            
            metalHitNodes.forEach(hit => {
                hit.osc.start(now);
                hit.osc.stop(now + duration);
            });
            
            if (grindNoise) {
                grindNoise.start(now);
                grindNoise.stop(now + duration);
            }
            
            if (lowRumble) {
                lowRumble.start(now);
                lowRumble.stop(now + duration);
            }
        }

        function createMovementSound(velocity, direction, complexity, turbulenceLevel, accel) {
            const now = audioContext.currentTime;
            const baseFreq = quantizePitch(mouseY);
            const velocityMag = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
            
            if (velocityMag < 0.02) return;
            
            const duration = 0.4 + Math.min(velocityMag * 2, 2.0);
            const velocityCurve = Math.pow(velocityMag, 1.5);
            
            const accelBoost = 1 + Math.max(-0.4, Math.min(0.6, accel * 3));
            const baseAmplitude = (0.03 + velocityCurve * 0.15) * (1 + complexity * 0.4);
            const amplitude = baseAmplitude * accelBoost;
            
            const attackTime = accel > 0.1 ? 0.04 : 0.08;
            const horizontalPos = mouseX;
            
            const fundamental = audioContext.createOscillator();
            fundamental.type = 'sine';
            fundamental.frequency.value = baseFreq;
            
            const vibrato = audioContext.createOscillator();
            vibrato.frequency.value = (4 + Math.random() * 2) * (1 + complexity * 0.5);
            const vibratoGain = audioContext.createGain();
            vibratoGain.gain.value = baseFreq * 0.005 * (1 + complexity);
            vibrato.connect(vibratoGain);
            vibratoGain.connect(fundamental.frequency);
            vibrato.start(now);
            vibrato.stop(now + duration);
            
            const fundEnv = audioContext.createGain();
            fundEnv.gain.value = 0;
            
            if (accel > 0.1) {
                fundEnv.gain.linearRampToValueAtTime(amplitude * 0.6, now + attackTime);
                fundEnv.gain.linearRampToValueAtTime(amplitude, now + duration * 0.5);
                fundEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
            } else if (accel < -0.1) {
                fundEnv.gain.linearRampToValueAtTime(amplitude, now + attackTime);
                fundEnv.gain.linearRampToValueAtTime(amplitude * 0.4, now + duration * 0.6);
                fundEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.8);
            } else {
                fundEnv.gain.linearRampToValueAtTime(amplitude, now + attackTime);
                fundEnv.gain.linearRampToValueAtTime(amplitude * 0.8, now + duration * 0.7);
                fundEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
            }
            
            const baseNumHarmonics = Math.floor(2 + complexity * 2);
            const numHarmonics = Math.floor(baseNumHarmonics + horizontalPos * 2);
            const harmonics = [];
            const harmonicRatios = [1.5, 2, 3, 4, 5, 6];
            
            for (let i = 0; i < numHarmonics; i++) {
                const harmOsc = audioContext.createOscillator();
                harmOsc.type = 'sine';
                
                const detuning = (Math.random() - 0.5) * turbulenceLevel * 8;
                harmOsc.frequency.value = baseFreq * harmonicRatios[i] + detuning;
                
                const harmEnv = audioContext.createGain();
                harmEnv.gain.value = 0;
                const harmonicBoost = 1 + (horizontalPos * 0.5);
                const harmAmp = amplitude * (0.2 - i * 0.04) * (1 + complexity * 0.3) * harmonicBoost;
                harmEnv.gain.linearRampToValueAtTime(harmAmp, now + attackTime);
                harmEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                harmOsc.connect(harmEnv);
                harmonics.push({ osc: harmOsc, env: harmEnv });
            }
            
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            noise.loop = true;
            
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = baseFreq * 1.5;
            noiseFilter.Q.value = 2 + velocityCurve * 4 + complexity * 2;
            
            const noiseEnv = audioContext.createGain();
            noiseEnv.gain.value = 0;
            const noiseAmp = amplitude * 0.3 * velocityCurve * (1 + complexity * 0.5 + turbulenceLevel * 1.5);
            noiseEnv.gain.linearRampToValueAtTime(noiseAmp, now + 0.05);
            noiseEnv.gain.linearRampToValueAtTime(noiseAmp * 0.5, now + duration * 0.5);
            noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const mainFilter = audioContext.createBiquadFilter();
            mainFilter.type = 'lowpass';
            const baseFilterFreq = baseFreq * (3 + complexity * 2 + velocityCurve * 2 + turbulenceLevel * 1.5);
            const horizontalFilterBoost = 1 + (horizontalPos * 2);
            // CLAMP filter frequency to valid range (20Hz - 20000Hz to be safe)
            mainFilter.frequency.value = Math.max(20, Math.min(20000, baseFilterFreq * horizontalFilterBoost + velocityCurve * 1200));
            mainFilter.Q.value = 0.7 + complexity * 0.5 + turbulenceLevel * 0.8 + (horizontalPos * 0.5);
            
            const dryGain = audioContext.createGain();
            const wetGain = audioContext.createGain();
            dryGain.gain.value = 1 - (horizontalPos * 0.4);
            wetGain.gain.value = 0.3 + (horizontalPos * 0.5);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (mouseX - 0.5) * 2.4)); // Slightly more pronounced panning
            
            fundamental.connect(fundEnv);
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseEnv);
            
            fundEnv.connect(mainFilter);
            harmonics.forEach(h => h.env.connect(mainFilter));
            noiseEnv.connect(mainFilter);
            
            mainFilter.connect(panner);
            panner.connect(dryGain);
            panner.connect(wetGain);
            
            dryGain.connect(masterGain);
            wetGain.connect(convolver);
            
            fundamental.start(now);
            fundamental.stop(now + duration);
            harmonics.forEach(h => {
                h.osc.start(now);
                h.osc.stop(now + duration);
            });
            noise.start(now);
            noise.stop(now + duration);
            
            if (velocityMag > 0.3 && Math.random() < 0.2 + complexity * 0.3) {
                createAirPuff(velocityMag * (1 + complexity * 0.5));
            }
        }
        
        function createStopAccent(prevVelocity) {
            const now = audioContext.currentTime;
            const baseFreq = quantizePitch(mouseY);
            const duration = 0.15;
            
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = baseFreq;
            osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, now + duration);
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            const accentVolume = Math.min(prevVelocity * 0.15, 0.2);
            env.gain.linearRampToValueAtTime(accentVolume, now + 0.01);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 2);
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = baseFreq * 2;
            noiseFilter.Q.value = 2;
            
            const noiseEnv = audioContext.createGain();
            noiseEnv.gain.value = 0;
            noiseEnv.gain.linearRampToValueAtTime(accentVolume * 0.3, now + 0.005);
            noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (mouseX - 0.5) * 2.4)); // Slightly more pronounced panning
            
            osc.connect(env);
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseEnv);
            
            env.connect(panner);
            noiseEnv.connect(panner);
            panner.connect(masterGain);
            panner.connect(convolver);
            
            osc.start(now);
            osc.stop(now + duration);
            noise.start(now);
        }
        
        function createSplashSound(x, y) {
            const now = audioContext.currentTime;
            const baseFreq = quantizePitch(y);
            const duration = 0.8 + Math.random() * 0.3;
            
            const fundamental = audioContext.createOscillator();
            fundamental.type = 'sine';
            fundamental.frequency.value = baseFreq * 0.5;
            fundamental.frequency.exponentialRampToValueAtTime(baseFreq * 0.4, now + duration);
            
            const fundEnv = audioContext.createGain();
            fundEnv.gain.value = 0;
            fundEnv.gain.linearRampToValueAtTime(0.15, now + 0.02);
            fundEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const sparkle = audioContext.createOscillator();
            sparkle.type = 'sine';
            sparkle.frequency.value = baseFreq * 4 + Math.random() * 500;
            sparkle.frequency.exponentialRampToValueAtTime(baseFreq * 2, now + duration * 0.3);
            
            const sparkleEnv = audioContext.createGain();
            sparkleEnv.gain.value = 0;
            sparkleEnv.gain.linearRampToValueAtTime(0.08, now + 0.01);
            sparkleEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.4);
            
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 1.5);
            }
            
            const splash = audioContext.createBufferSource();
            splash.buffer = noiseBuffer;
            
            const splashFilter = audioContext.createBiquadFilter();
            splashFilter.type = 'bandpass';
            splashFilter.frequency.value = baseFreq * 2;
            splashFilter.Q.value = 3;
            
            const splashEnv = audioContext.createGain();
            splashEnv.gain.value = 0;
            splashEnv.gain.linearRampToValueAtTime(0.12, now + 0.005);
            splashEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2.6)); // Slightly more pronounced panning
            
            fundamental.connect(fundEnv);
            sparkle.connect(sparkleEnv);
            splash.connect(splashFilter);
            splashFilter.connect(splashEnv);
            
            fundEnv.connect(panner);
            sparkleEnv.connect(panner);
            splashEnv.connect(panner);
            
            panner.connect(masterGain);
            panner.connect(convolver);
            
            fundamental.start(now);
            fundamental.stop(now + duration);
            sparkle.start(now);
            sparkle.stop(now + duration * 0.4);
            splash.start(now);
        }
        
        function createHarmonicRipple(complexity) {
            const now = audioContext.currentTime;
            const baseFreq = quantizePitch(mouseY);
            const duration = 0.3 + complexity * 0.4;
            
            const intervals = [1.25, 1.5, 2];
            const interval = intervals[Math.floor(Math.random() * intervals.length)];
            
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = baseFreq * interval;
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            const amp = 0.02 * complexity;
            env.gain.linearRampToValueAtTime(amp, now + 0.05);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = baseFreq * interval * 2;
            filter.Q.value = 2;
            
            const panner = audioContext.createStereoPanner();
            const panOffset = (Math.random() - 0.5) * 0.6;
            panner.pan.value = Math.max(-1, Math.min(1, (mouseX - 0.5) * 2.4 + panOffset)); // Slightly more pronounced panning
            
            osc.connect(filter);
            filter.connect(env);
            env.connect(panner);
            panner.connect(convolver);
            
            osc.start(now);
            osc.stop(now + duration);
        }
        
        function createAirPuff(intensity) {
            const now = audioContext.currentTime;
            const duration = 0.12;
            
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 2000 + Math.random() * 1000;
            filter.Q.value = 1;
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(0.03 * intensity, now + 0.01);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (mouseX - 0.5) * 2.6)); // Slightly more pronounced panning
            
            noise.connect(filter);
            filter.connect(env);
            env.connect(panner);
            panner.connect(convolver);
            
            noise.start(now);
            noise.stop(now + duration);
        }
        
        function updateAudio() {
            if (!audioEnabled) return;
            
            const velocity = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
            const now = audioContext.currentTime;
            
            const currentAcceleration = velocity - prevVelocityMag;
            acceleration = acceleration * 0.7 + currentAcceleration * 0.3;
            prevVelocityMag = velocity;
            
            if (velocity > 0.01) {
                recentVelocities.push({ 
                    vx: mouseVelX, 
                    vy: mouseVelY,
                    mag: velocity,
                    time: Date.now() 
                });
                if (recentVelocities.length > MAX_VELOCITIES) {
                    recentVelocities.shift();
                }
            }
            
            if (recentVelocities.length > 3) {
                let avgVx = 0, avgVy = 0, avgMag = 0;
                recentVelocities.forEach(v => {
                    avgVx += v.vx;
                    avgVy += v.vy;
                    avgMag += v.mag;
                });
                avgVx /= recentVelocities.length;
                avgVy /= recentVelocities.length;
                avgMag /= recentVelocities.length;
                
                let dirVariance = 0;
                let magVariance = 0;
                recentVelocities.forEach(v => {
                    const dx = v.vx - avgVx;
                    const dy = v.vy - avgVy;
                    dirVariance += dx * dx + dy * dy;
                    magVariance += Math.pow(v.mag - avgMag, 2);
                });
                dirVariance /= recentVelocities.length;
                magVariance /= recentVelocities.length;
                
                const rawTurbulence = Math.min((dirVariance * 50 + magVariance * 100), 1);
                turbulence = turbulence * 0.9 + rawTurbulence * 0.1;
            } else {
                turbulence *= 0.95;
            }
            
            if (velocity > 0.02) {
                recentPositions.push({ x: mouseX, y: mouseY, time: Date.now() });
                if (recentPositions.length > MAX_POSITIONS) {
                    recentPositions.shift();
                }
            }
            
            const currentTime = Date.now();
            recentPositions = recentPositions.filter(pos => currentTime - pos.time < 2000);
            recentVelocities = recentVelocities.filter(v => currentTime - v.time < 1000);
            
            if (recentPositions.length > 5) {
                let avgX = 0, avgY = 0;
                recentPositions.forEach(pos => {
                    avgX += pos.x;
                    avgY += pos.y;
                });
                avgX /= recentPositions.length;
                avgY /= recentPositions.length;
                
                let spread = 0;
                recentPositions.forEach(pos => {
                    const dx = pos.x - avgX;
                    const dy = pos.y - avgY;
                    spread += Math.sqrt(dx * dx + dy * dy);
                });
                spread /= recentPositions.length;
                
                const targetConcentration = Math.max(0, 1 - spread * 5);
                areaConcentration = areaConcentration * 0.95 + targetConcentration * 0.05;
            } else {
                areaConcentration *= 0.98;
            }
            
            movementMomentum += velocity * 0.8;
            movementMomentum = Math.min(movementMomentum, 3.0);
            movementMomentum *= 0.97;
            
            if (echoGain && echoTone && echoFilter) {
                const echoVolume = movementMomentum * 0.015;
                echoGain.gain.linearRampToValueAtTime(echoVolume, now + 0.5);
                
                const targetPitch = quantizePitch(mouseY);
                echoTone.frequency.linearRampToValueAtTime(targetPitch, now + 0.8);
                
                const filterFreq = 300 + movementMomentum * 400;
                echoFilter.frequency.linearRampToValueAtTime(filterFreq, now + 0.6);
            }
            
            if (rootGain) {
                const rootVolume = Math.min((movementMomentum * 0.008 + areaConcentration * 0.012), 0.025);
                rootGain.gain.linearRampToValueAtTime(rootVolume, now + 0.4);
            }
            
            if (velocity > 0.02 && Date.now() - lastSoundTime > 50) {
                createMovementSound(
                    { x: mouseVelX, y: mouseVelY },
                    { x: mouseVelX / Math.max(0.01, velocity), y: mouseVelY / Math.max(0.01, velocity) },
                    areaConcentration,
                    turbulence,
                    acceleration
                );
                lastSoundTime = Date.now();
                
                if (areaConcentration > 0.5 && Math.random() < areaConcentration) {
                    setTimeout(() => {
                        if (audioEnabled) createHarmonicRipple(areaConcentration);
                    }, 50 + Math.random() * 100);
                }
            }
            
            if (prevVelocityMag > 0.3 && velocity < 0.05 && acceleration < -0.2) {
                createStopAccent(prevVelocityMag);
            }
        }
        
        /*
         * AUDIO CLEANUP FUNCTION
         * This prevents sound caching issues when refreshing the page
         * - Stops all beat intervals
         * - Closes the audio context properly
         * - Clears any lingering audio nodes
         */
        function cleanupAudio() {
            // Stop all beat intervals
            Object.keys(beatEffects).forEach(key => {
                stopBeat(key);
            });
            
            // Stop all Oramics drones
            stopAllDrones();
            
            // Clear sequencer zones
            sequencerZones = [];
            
            // Clear all polyrhythm timers
            polyrhythmTimers.forEach(timer => clearTimeout(timer));
            polyrhythmTimers = [];
            
            // Close audio context if it exists
            if (audioContext && audioContext.state !== 'closed') {
                try {
                    audioContext.close();
                } catch(e) {
                    console.log('Audio context cleanup:', e);
                }
            }
            
            audioEnabled = false;
            audioContext = null;
        }
        
        // Clean up audio when page is about to unload (refresh/close)
        window.addEventListener('beforeunload', cleanupAudio);
        
        // Also clean up when visibility changes (switching tabs)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && audioContext) {
                // Pause/suspend audio when tab is hidden to prevent issues
                if (audioContext.state === 'running') {
                    audioContext.suspend();
                }
            } else if (!document.hidden && audioContext && audioEnabled) {
                // Resume audio when tab is visible again
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }
        });
        
        window.addEventListener('DOMContentLoaded', function() {
            initColorPalette();
            initGlitchPanel();
            initBeatPanel();
            initOramicsPanel();
            
            const toggleBtn = document.getElementById('toggleAudio');
            const audioPanel = document.getElementById('audioPanel');
            const colorPalette = document.getElementById('colorPalette');
            
            if (toggleBtn) {
                // iOS: Add BOTH click AND touchstart for better compatibility
                const handleToggle = async function() {
                    console.log('🔘 Sound button activated');
                    if (!audioEnabled) {
                        try {
                            console.log('🎵 Calling initAudio()...');
                            await initAudio();
                            // Don't set audioEnabled here - let initAudio() set it
                            this.textContent = 'Sound Off';
                            audioPanel.classList.add('expanded');
                            colorPalette.classList.add('visible');
                            
                            // iOS CRITICAL: Auto-select first color (Grey) on mobile
                            if ('ontouchstart' in window) {
                                setTimeout(() => {
                                    selectedColorIndex = 0; // Select Grey automatically
                                    const firstSwatch = document.querySelector('.color-swatch');
                                    if (firstSwatch) {
                                        firstSwatch.classList.add('selected');
                                    }
                                    console.log('✓ Auto-selected color 0 (Grey) for mobile');
                                }, 50);
                            }
                            
                            // Diagnostic logging only (no more alerts!)
                            setTimeout(() => {
                                console.log('✅ AUDIO READY - State:', audioContext ? audioContext.state : 'null', 'Enabled:', audioEnabled, 'Color:', selectedColorIndex);
                            }, 200);
                            
                            console.log('✓ Audio initialized, state:', audioContext ? audioContext.state : 'no context');
                        } catch (e) {
                            console.error('❌ Audio init error:', e);
                        }
                    } else {
                        audioEnabled = false;
                        if (audioContext) audioContext.close();
                        audioContext = null;
                        this.textContent = 'Sound On';
                        audioPanel.classList.remove('expanded');
                        colorPalette.classList.remove('visible');
                        
                        // Deactivate all glitch effects when audio is off
                        Object.keys(glitchEffects).forEach(key => {
                            if (glitchEffects[key].active) {
                                glitchEffects[key].active = false;
                                const btn = document.querySelector(`[data-glitch="${key}"]`);
                                if (btn) btn.classList.remove('active');
                            }
                        });
                        
                        // Deactivate all beat effects when audio is off
                        Object.keys(beatEffects).forEach(key => {
                            if (beatEffects[key].active) {
                                stopBeat(key);
                                beatEffects[key].active = false;
                                const btn = document.querySelector(`[data-beat="${key}"]`);
                                if (btn) btn.classList.remove('active');
                            }
                        });
                        
                        // Deactivate all Oramics effects when audio is off
                        Object.keys(oramicsEffects).forEach(key => {
                            if (oramicsEffects[key].active) {
                                oramicsEffects[key].active = false;
                                const btn = document.querySelector(`[data-oramics="${key}"]`);
                                if (btn) btn.classList.remove('active');
                            }
                        });
                        
                        selectedColorIndex = -1;
                        document.querySelectorAll('.color-swatch').forEach(swatch => {
                            swatch.classList.remove('selected');
                        });
                    }
                };
                
                // Add BOTH click and touchstart listeners for iOS compatibility
                toggleBtn.addEventListener('click', handleToggle);
                toggleBtn.addEventListener('touchstart', handleToggle, { passive: false });
                console.log('✓ Sound button listeners added (click + touchstart)');
            }
        });

        let renderFrameCount = 0;
        let lastRenderLog = 0;
        
        function render(time) {
            renderFrameCount++;
            if (renderFrameCount === 1) {
                console.log('✅ RENDER LOOP STARTED');
            }
            
            // Log every 60 frames (once per second at 60fps)
            if (renderFrameCount % 60 === 0) {
                console.log('🔄 Render frame', renderFrameCount, '- pendingClicks:', pendingClicks.length);
            }
            
            time *= 0.001;
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            
            // Apply visual glitch effects
            applyVisualGlitches();
            
            const dt = Math.min(1.0 / 60.0, 0.016);
            const deltaX = (mouseX - lastMouseX) * 10.0;
            const deltaY = (mouseY - lastMouseY) * 10.0;
            
            mouseVelX = deltaX;
            mouseVelY = deltaY;
            
            // ===== ORAMICS GESTURE TRACKING =====
            // Track gesture metrics when painted envelope is active and painting is happening
            if (oramicsEffects.paintedEnvelope.active && selectedColorIndex >= 0) {
                const isMoving = Math.abs(deltaX) > 0.01 || Math.abs(deltaY) > 0.01;
                
                if (isMoving) {
                    if (!isGestureActive) {
                        // Start of new gesture
                        isGestureActive = true;
                        gestureStartTime = Date.now();
                        gesturePathLength = 0;
                        gestureAvgVelocity = 0;
                        lastGesturePos = { x: mouseX, y: mouseY };
                    } else {
                        // Continue gesture - accumulate path length
                        const distance = Math.sqrt(
                            Math.pow(mouseX - lastGesturePos.x, 2) + 
                            Math.pow(mouseY - lastGesturePos.y, 2)
                        );
                        gesturePathLength += distance;
                        lastGesturePos = { x: mouseX, y: mouseY };
                        
                        // Calculate average velocity
                        const currentVelocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        gestureAvgVelocity = (gestureAvgVelocity * 0.9) + (currentVelocity * 0.1);
                    }
                } else {
                    // End of gesture
                    isGestureActive = false;
                }
            } else {
                isGestureActive = false;
            }
            
            // ===== GENERAL PAINTING VELOCITY & CURVATURE TRACKING =====
            /*
             * Track velocity and curvature for all painting (not just Oramics)
             * Faster painting = louder/brighter sound
             * Curved gestures = subtle timbral variation
             */
            const now = Date.now();
            const timeDelta = (now - lastPaintingTime) / 1000; // seconds
            const isMoving = Math.abs(deltaX) > 0.01 || Math.abs(deltaY) > 0.01;
            
            if (isMoving && timeDelta > 0) {
                // Calculate instantaneous velocity
                const distance = Math.sqrt(
                    Math.pow(mouseX - lastPaintingPos.x, 2) + 
                    Math.pow(mouseY - lastPaintingPos.y, 2)
                );
                const instantVelocity = distance / timeDelta;
                
                // Smooth velocity using exponential moving average
                currentPaintingVelocity = (currentPaintingVelocity * velocitySmoothing) + 
                                         (instantVelocity * (1 - velocitySmoothing));
                
                // Track gesture history for curvature detection
                gestureHistory.push({ x: mouseX, y: mouseY, time: now });
                if (gestureHistory.length > MAX_GESTURE_HISTORY) {
                    gestureHistory.shift(); // Remove oldest
                }
                
                // Calculate curvature if we have enough history
                if (gestureHistory.length >= 3) {
                    // Measure angle changes between consecutive segments
                    let totalAngleChange = 0;
                    for (let i = 1; i < gestureHistory.length - 1; i++) {
                        const p1 = gestureHistory[i - 1];
                        const p2 = gestureHistory[i];
                        const p3 = gestureHistory[i + 1];
                        
                        // Calculate angles
                        const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                        const angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                        
                        // Angle change (in radians)
                        let angleDiff = Math.abs(angle2 - angle1);
                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                        
                        totalAngleChange += angleDiff;
                    }
                    
                    // Normalize to 0-1 range (0 = straight, 1 = very curved)
                    gestureCurvature = Math.min(totalAngleChange / Math.PI, 1.0);
                } else {
                    gestureCurvature = 0;
                }
                
                lastPaintingPos = { x: mouseX, y: mouseY };
                lastPaintingTime = now;
            } else {
                // Gradually decay velocity when not moving
                currentPaintingVelocity *= 0.95;
                gestureCurvature *= 0.95;
            }
            
            // ===== DRAWN WAVEFORMS UPDATE =====
            /*
             * Periodically sample the visual field and convert to audio waveform
             * Like Oram's photoelectric reader scanning the film strip
             */
            if (oramicsEffects.drawnWaveforms.active && audioEnabled) {
                const now = Date.now();
                if (now - lastWaveformUpdateTime > WAVEFORM_UPDATE_RATE) {
                    const waveformData = sampleVisualWaveform();
                    if (waveformData) {
                        visualWaveformBuffer = waveformData;
                        lastWaveformUpdateTime = now;
                        
                        // Calculate average brightness for debugging
                        const avgBrightness = waveformData.reduce((sum, val) => sum + Math.abs(val), 0) / waveformData.length;
                        console.log(`Waveform updated - Avg brightness: ${avgBrightness.toFixed(3)}`);
                    }
                }
            }
            
            if (pendingClicks.length > 0) {
                // ALWAYS log when processing splats for debugging
                console.log('💦 Processing', pendingClicks.length, 'splats at frame', renderFrameCount);
                
                // Visual confirmation - flash the background briefly
                if (pendingClicks.length > 0) {
                    document.body.style.backgroundColor = 'rgba(0,255,0,0.1)';
                    setTimeout(() => document.body.style.backgroundColor = '#000', 100);
                }
                
                pendingClicks.forEach(click => {
                    // Velocity splash
                    gl.useProgram(splatProgram);
                    const posLoc = gl.getAttribLocation(splatProgram, 'position');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(velocity.write);
                    gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), click.x, click.y);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const force = 15.0;
                    gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                        Math.cos(angle) * force, 
                        Math.sin(angle) * force, 
                        0.0
                    );
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.008);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    
                    velocity.swap();
                    
                    // RE-ENABLED FOR iOS: Color ink drop on click
                    // iOS needs more aggressive visual feedback
                    if (selectedColorIndex >= 0) {
                        const voice = colorVoices[selectedColorIndex];
                        
                        gl.useProgram(colorSplatProgram);
                        const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                        gl.enableVertexAttribArray(colorPosLoc);
                        gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                        
                        bindFramebuffer(colorBuffer.write);
                        gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                        gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), click.x, click.y);
                        
                        gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                            voice.color.r * 1.2, 
                            voice.color.g * 1.2, 
                            voice.color.b * 1.2
                        );
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.003);
                        
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        
                        colorBuffer.swap();
                    }
                });
                pendingClicks = [];
            }
            
            if (Math.abs(deltaX) > 0.01 || Math.abs(deltaY) > 0.01) {
                // Splat velocity
                gl.useProgram(splatProgram);
                const posLoc = gl.getAttribLocation(splatProgram, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                bindFramebuffer(velocity.write);
                gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), mouseX, mouseY);
                gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), deltaX, deltaY, 0.0);
                gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.002);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                velocity.swap();
                
                // Inject color ink if selected
                if (selectedColorIndex >= 0) {
                    const voice = colorVoices[selectedColorIndex];
                    
                    // Check if any rhythmic effect is active for color trail
                    const colorTrailActive = oramicsEffects.arpeggiator.active || 
                                            oramicsEffects.stutter.active || 
                                            oramicsEffects.polyrhythm.active;
                    
                    gl.useProgram(colorSplatProgram);
                    const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                    gl.enableVertexAttribArray(colorPosLoc);
                    gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    const injectionStrength = 0.8;
                    
                    if (colorTrailActive) {
                        // TRAIL EFFECT: Different effects based on which rhythmic button is active
                        const useRainbowTrail = oramicsEffects.polyrhythm.active;
                        
                        if (useRainbowTrail) {
                            // RAINBOW TRAIL for Polyrhythm (◈)
                            // Paint trail at recent previous positions with rainbow colors
                            previousPaintPositions.forEach((pos, index) => {
                                bindFramebuffer(colorBuffer.write);
                                gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                                gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                                gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), pos.x, pos.y);
                                
                                // Trail fades as it gets older - SUPER STRONG NOW
                                const fadeAmount = 0.7 + (index / previousPaintPositions.length) * 1.0; // 0.7 to 1.7 (very bright!)
                                
                                // Calculate rainbow color based on position in trail
                                // Cycle through hue values (0-360 degrees)
                                const hue = (index / previousPaintPositions.length) * 360; // 0° to 360°
                                
                                // Convert HSL to RGB for rainbow effect
                                const h = hue / 60;
                                const c = 1; // Full saturation
                                const x = c * (1 - Math.abs((h % 2) - 1));
                                
                                let r, g, b;
                                if (h >= 0 && h < 1) { r = c; g = x; b = 0; }
                                else if (h >= 1 && h < 2) { r = x; g = c; b = 0; }
                                else if (h >= 2 && h < 3) { r = 0; g = c; b = x; }
                                else if (h >= 3 && h < 4) { r = 0; g = x; b = c; }
                                else if (h >= 4 && h < 5) { r = x; g = 0; b = c; }
                                else { r = c; g = 0; b = x; }
                                
                                gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                                    r * injectionStrength * fadeAmount * 2.5, // Boosted by 2.5x - MUCH STRONGER!
                                    g * injectionStrength * fadeAmount * 2.5,
                                    b * injectionStrength * fadeAmount * 2.5
                                );
                                gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.006); // 3x larger radius - BOLD!
                                
                                gl.activeTexture(gl.TEXTURE0);
                                gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                                
                                colorBuffer.swap();
                            });
                        } else {
                            // TWO-COLOR GRADIENT TRAIL for Arpeggiator (⟨⟩) and Stutter (⧈)
                            const secondaryColorIndex = colorMorphMap[selectedColorIndex];
                            const secondaryVoice = colorVoices[secondaryColorIndex];
                            
                            // Paint trail at recent previous positions
                            previousPaintPositions.forEach((pos, index) => {
                                bindFramebuffer(colorBuffer.write);
                                gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                                gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                                gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), pos.x, pos.y);
                                
                                // Trail fades as it gets older (oldest = most transparent)
                                const fadeAmount = (index / previousPaintPositions.length) * 0.7; // 0 to 0.7
                                
                                gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                                    secondaryVoice.color.r * injectionStrength * fadeAmount,
                                    secondaryVoice.color.g * injectionStrength * fadeAmount,
                                    secondaryVoice.color.b * injectionStrength * fadeAmount
                                );
                                gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.002);
                                
                                gl.activeTexture(gl.TEXTURE0);
                                gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                                
                                colorBuffer.swap();
                            });
                        }
                        
                        // Store current position for next frame's trail
                        previousPaintPositions.push({ x: mouseX, y: mouseY });
                        if (previousPaintPositions.length > MAX_TRAIL_LENGTH) {
                            previousPaintPositions.shift(); // Remove oldest
                        }
                    }
                    
                    // Always paint PRIMARY color at CURRENT position (the head)
                    bindFramebuffer(colorBuffer.write);
                    gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), mouseX, mouseY);
                    
                    gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                        voice.color.r * injectionStrength, 
                        voice.color.g * injectionStrength, 
                        voice.color.b * injectionStrength
                    );
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.0015);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    
                    colorBuffer.swap();
                    
                    lastColorIntensity = lastColorIntensity * 0.99 + injectionStrength;
                    
                    if (audioEnabled && Date.now() - lastSoundTime > 80) {
                        // Determine which trigger function to use
                        let triggerFunc;
                        if (oramicsEffects.textureMode2.active) {
                            triggerFunc = (x, y, intensity) => triggerTextureSound2(x, y, intensity);
                        } else if (oramicsEffects.textureMode.active) {
                            triggerFunc = (x, y, intensity) => triggerTextureSound(x, y, intensity);
                        } else {
                            triggerFunc = (x, y, intensity) => triggerColorVoice(selectedColorIndex, x, y, intensity);
                        }
                        
                        // Trigger main sound
                        triggerFunc(mouseX, mouseY, lastColorIntensity);
                        
                        // Apply rhythmic pattern effects (they add additional triggers)
                        processStutter(mouseX, mouseY, lastColorIntensity, triggerFunc);
                        processPolyrhythm(mouseX, mouseY, lastColorIntensity, triggerFunc);
                        
                        lastSoundTime = Date.now();
                    }
                } else {
                    lastColorIntensity *= 0.99;
                    // Clear trail positions when not moving (ready for new stroke)
                    if (previousPaintPositions.length > 0) {
                        previousPaintPositions = [];
                    }
                }
                
                updateAudio();
            }
            
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Diffuse color - creates organic watercolor spreading
            gl.useProgram(diffusionProgram);
            const diffPosLoc = gl.getAttribLocation(diffusionProgram, 'position');
            gl.enableVertexAttribArray(diffPosLoc);
            gl.vertexAttribPointer(diffPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            for (let i = 0; i < 3; i++) {
                bindFramebuffer(colorBuffer.write);
                gl.uniform1i(gl.getUniformLocation(diffusionProgram, 'uSource'), 0);
                gl.uniform2f(gl.getUniformLocation(diffusionProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
                gl.uniform1f(gl.getUniformLocation(diffusionProgram, 'diffusionRate'), currentDiffusion * 0.15);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                colorBuffer.swap();
            }
            
            // Advect color with velocity field
            gl.useProgram(advectionProgram);
            const advPosLoc = gl.getAttribLocation(advectionProgram, 'position');
            gl.enableVertexAttribArray(advPosLoc);
            gl.vertexAttribPointer(advPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            bindFramebuffer(colorBuffer.write);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uSource'), 1);
            gl.uniform2f(gl.getUniformLocation(advectionProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dt'), dt);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dissipation'), 0.99);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            colorBuffer.swap();
            
            // Advect velocity
            bindFramebuffer(velocity.write);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uSource'), 1);
            gl.uniform2f(gl.getUniformLocation(advectionProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dt'), dt);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dissipation'), 0.995);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            velocity.swap();
            
            gl.useProgram(divergenceProgram);
            const divPosLoc = gl.getAttribLocation(divergenceProgram, 'position');
            gl.enableVertexAttribArray(divPosLoc);
            gl.vertexAttribPointer(divPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            bindFramebuffer(divergence);
            gl.uniform1i(gl.getUniformLocation(divergenceProgram, 'uVelocity'), 0);
            gl.uniform2f(gl.getUniformLocation(divergenceProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            bindFramebuffer(pressure.read);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(pressureProgram);
            const pressPosLoc = gl.getAttribLocation(pressureProgram, 'position');
            gl.enableVertexAttribArray(pressPosLoc);
            gl.vertexAttribPointer(pressPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            for (let i = 0; i < 20; i++) {
                bindFramebuffer(pressure.write);
                gl.uniform1i(gl.getUniformLocation(pressureProgram, 'uPressure'), 0);
                gl.uniform1i(gl.getUniformLocation(pressureProgram, 'uDivergence'), 1);
                gl.uniform2f(gl.getUniformLocation(pressureProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, divergence.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                pressure.swap();
            }
            
            gl.useProgram(gradientSubtractProgram);
            const gradPosLoc = gl.getAttribLocation(gradientSubtractProgram, 'position');
            gl.enableVertexAttribArray(gradPosLoc);
            gl.vertexAttribPointer(gradPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            bindFramebuffer(velocity.write);
            gl.uniform1i(gl.getUniformLocation(gradientSubtractProgram, 'uPressure'), 0);
            gl.uniform1i(gl.getUniformLocation(gradientSubtractProgram, 'uVelocity'), 1);
            gl.uniform2f(gl.getUniformLocation(gradientSubtractProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            velocity.swap();
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(displayProgram);
            
            const dispPosLoc = gl.getAttribLocation(displayProgram, 'position');
            gl.enableVertexAttribArray(dispPosLoc);
            gl.vertexAttribPointer(dispPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'uColor'), 1);
            gl.uniform1f(gl.getUniformLocation(displayProgram, 'time'), time);
            gl.uniform2f(gl.getUniformLocation(displayProgram, 'resolution'), canvas.width, canvas.height);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            // ===== ORAMICS EFFECTS PROCESSING =====
            
            // Pattern Sequencer: Check if fluid flows through painted zones
            if (oramicsEffects.patternSequencer.active && sequencerZones.length > 0) {
                const now = Date.now();
                
                // Read velocity data to detect fluid flow
                try {
                    const pixels = new Uint8Array(simWidth * simHeight * 4);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.read.fbo);
                    gl.readPixels(0, 0, simWidth, simHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                    
                    sequencerZones.forEach(zone => {
                        // Check if enough time has passed since last trigger (cooldown)
                        if (now - zone.lastTriggerTime < ZONE_TRIGGER_COOLDOWN) return;
                        
                        // Sample velocity at zone position
                        const zoneX = Math.floor(zone.x * simWidth);
                        const zoneY = Math.floor(zone.y * simHeight);
                        const pixelIndex = (zoneY * simWidth + zoneX) * 4;
                        
                        // Get velocity magnitude (stored in R and G channels)
                        const vx = (pixels[pixelIndex] / 255.0) - 0.5;
                        const vy = (pixels[pixelIndex + 1] / 255.0) - 0.5;
                        const velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
                        
                        // If fluid is flowing through this zone, trigger a note!
                        if (velocityMagnitude > 0.01) { // MUCH lower threshold = SUPER sensitive triggering!
                            // Check which mode is active
                            // EXTREME: Much louder triggering!
                            if (oramicsEffects.textureMode2.active) {
                                triggerTextureSound2(zone.x, zone.y, 0.5); // 2.5x louder!
                            } else if (oramicsEffects.textureMode.active) {
                                triggerTextureSound(zone.x, zone.y, 0.5); // 2.5x louder!
                            } else {
                                triggerColorVoice(zone.color, zone.x, zone.y, 0.5); // 2.5x louder!
                            }
                            zone.lastTriggerTime = now;
                            const modeText = oramicsEffects.textureMode2.active ? 'texture2' : 
                                           oramicsEffects.textureMode.active ? 'texture1' : zone.color;
                            console.log('⊞ Sequencer triggered:', modeText);
                        }
                    });
                } catch (e) {
                    // Silently fail if can't read pixels
                }
            }
            
            // Gesture Drones: Evolve all active drones
            if (oramicsEffects.gestureDrones.active && activeDrones.length > 0) {
                evolveDrones();
            }
            
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>