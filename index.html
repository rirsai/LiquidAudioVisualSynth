<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metallic Fluid Synth</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 100;
        }
        
        #audioPanel {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border: 0.75pt solid rgba(255, 255, 255, 0.95);
            border-radius: 0;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        
        #audioPanel.expanded {
            gap: 20px;
        }
        
        #toggleAudio {
            background: transparent;
            border: none;
            color: white;
            font-size: 13px;
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.2s;
            white-space: nowrap;
            padding: 0;
            margin: 0;
            line-height: 1;
            text-transform: uppercase;
        }
        
        #toggleAudio:hover {
            opacity: 0.7;
        }
        
        #colorPalette {
            display: flex;
            gap: 12px;
            align-items: center;
            opacity: 0;
            width: 0;
            overflow: visible;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 4px 0;
        }
        
        #colorPalette.visible {
            opacity: 1;
            width: auto;
        }
        
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            border: 0.75pt solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
        }
        
        .color-swatch.selected {
            border-color: white;
            border-width: 1.5pt;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        /* Glitch Effects Divider */
        .glitch-divider {
            width: 0.75pt;
            height: 32px;
            background: rgba(255, 255, 255, 0.3);
            margin: 0 8px;
            flex-shrink: 0;
        }
        
        .glitch-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 0.75pt solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            flex-shrink: 0;
        }
        
        .glitch-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .glitch-btn.active {
            background: rgba(0, 0, 0, 0.8);
            border-color: white;
            border-width: 1.5pt;
            color: white;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        /* Beat Buttons */
        .beat-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 0.75pt solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            flex-shrink: 0;
        }
        
        .beat-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .beat-btn.active {
            background: rgba(0, 0, 0, 0.8);
            border-color: white;
            border-width: 1.5pt;
            color: white;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .beat-btn.pulse {
            animation: beatPulse 0.2s ease-out;
        }
        
        @keyframes beatPulse {
            0% { transform: scale(1.1); }
            50% { transform: scale(1.3); box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.9), 0 0 20px rgba(255, 255, 255, 0.9); }
            100% { transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <div id="audioPanel">
            <button id="toggleAudio">Sound On</button>
            <div id="colorPalette"></div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl', {
            alpha: false,
            depth: false,
            stencil: false,
            antialias: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL not supported');
        }

        const floatExt = gl.getExtension('OES_texture_float');
        const floatLinearExt = gl.getExtension('OES_texture_float_linear');

        let simWidth = 128;
        let simHeight = 128;

        function resize() {
            const dpr = Math.min(window.devicePixelRatio, 2);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
        }
        resize();
        window.addEventListener('resize', resize);

        // COLOR VOICE SYSTEM with persistence
        const colorVoices = [
            {
                color: { r: 0.4, g: 0.4, b: 0.4 },
                hex: '#666666',
                persistence: 0.8,
                diffusion: 0.3,
                sound: {
                    waveform: 'sine',
                    baseFreqMultiplier: 0.5,
                    harmonics: 1,
                    attack: 0.2,
                    filterType: 'lowpass',
                    filterFreq: 400,
                    filterQ: 1,
                    reverbMix: 0.8,
                    detune: 0
                }
            },
            {
                color: { r: 0.7, g: 0.4, b: 0.3 },
                hex: '#B36A49',
                persistence: 0.7,
                diffusion: 0.4,
                sound: {
                    waveform: 'triangle',
                    baseFreqMultiplier: 0.5,
                    harmonics: 3,
                    attack: 0.15,
                    filterType: 'lowpass',
                    filterFreq: 400,
                    filterQ: 2,
                    reverbMix: 0.4,
                    detune: 8,
                    // EARTHY TEXTURE - subtle grit and crackle layered on top
                    useHeavyDistortion: true,
                    distortionDrive: 2.5,  // Subtle warmth and grit
                    useBitCrusher: false,  // Too harsh, removed
                    useCrackle: true,
                    crackleRate: 18,  // Moderate crackles
                    crackleIntensity: 0.4,  // Quiet, background texture
                    useSubBass: true,
                    subBassFreq: 0.25,  // Low rumble
                    useRumble: true,
                    rumbleVolume: 0.25,  // Subtle rumble layer
                    heavyNoise: true,
                    noiseRatio: 0.6  // Present but not overwhelming
                }
            },
            {
                color: { r: 0.3, g: 0.4, b: 0.9 },
                hex: '#4D5DE8',
                persistence: 1.0,
                diffusion: 0.25,
                sound: {
                    waveform: 'sine',
                    baseFreqMultiplier: 0.5,
                    harmonics: 3,
                    attack: 0.3,
                    filterType: 'lowpass',
                    filterFreq: 500,
                    filterQ: 2,
                    reverbMix: 0.85,
                    detune: 12,
                    useModulation: true,
                    modulationRate: 0.3,
                    modulationDepth: 15
                }
            },
            {
                color: { r: 0.85, g: 0.9, b: 0.3 },
                hex: '#D9E64D',
                persistence: 0.4,
                diffusion: 0.6,
                sound: {
                    waveform: 'sawtooth',
                    baseFreqMultiplier: 6.0,
                    harmonics: 10,
                    attack: 0.02,
                    filterType: 'highpass',
                    filterFreq: 2500,
                    filterQ: 4,
                    reverbMix: 0.3,
                    detune: 40
                }
            },
            {
                color: { r: 0.2, g: 0.8, b: 0.4 },
                hex: '#33CC66',
                persistence: 0.8,
                diffusion: 0.35,
                sound: {
                    waveform: 'triangle',
                    baseFreqMultiplier: 2.5,
                    harmonics: 3,
                    attack: 0.001,  // Instant like bamboo strike
                    filterType: 'bandpass',
                    filterFreq: 1800,
                    filterQ: 6,
                    reverbMix: 0.95,  // Huge reverb for forest atmosphere
                    detune: 3,
                    // BAMBOO WIND CHIMES - hollow resonant tubes with multiple pitches
                    useBamboo: true,
                    bambooTubes: [1.0, 1.33, 1.5, 2.0, 2.67, 3.0, 4.0],  // Pentatonic-ish tuning
                    bambooDecay: 0.4,  // Long resonance
                    bambooVolume: 0.9,
                    useHollowResonance: true,  // Hollow tube effect
                    resonanceFreq: 0.75,  // Sub-frequency for hollow sound
                    useWindNoise: true,  // Air rushing through bamboo
                    windIntensity: 0.4,
                    useMetallicShimmer: true,  // High metallic overtones
                    shimmerCount: 8
                }
            },
            {
                color: { r: 0.95, g: 0.6, b: 0.7 },
                hex: '#F299B3',
                persistence: 1.0,
                diffusion: 0.3,
                sound: {
                    waveform: 'sine',
                    baseFreqMultiplier: 4.0,  // Very high pitch
                    harmonics: 1,
                    attack: 0.0005,  // Nearly instant like ice cracking
                    filterType: 'highpass',
                    filterFreq: 3000,  // Only high frequencies
                    filterQ: 2,
                    reverbMix: 0.98,  // Maximum reverb for frozen space
                    detune: 0,
                    // ICE CRYSTALS - brittle, crackling, frozen glass texture
                    useIceCrackle: true,
                    iceCrackleCount: 25,  // Many small cracks
                    crackleIntensity: 0.9,
                    crackleSpeed: 0.02,  // Very fast pops
                    useFrozenResonance: true,  // High pitched resonance
                    frozenPitches: [8.0, 10.0, 12.0, 15.0, 18.0],  // Very high harmonics
                    useGlassShatter: true,  // Scattered glass sounds
                    shatterDensity: 12,
                    useHighShimmer: true,  // Ultra-high frequency sparkle
                    shimmerFreq: 12.0
                }
            },
            {
                color: { r: 1.0, g: 0.4, b: 0.35 },
                hex: '#FF6659',
                persistence: 0.5,
                diffusion: 0.5,
                sound: {
                    waveform: 'sawtooth',
                    baseFreqMultiplier: 0.5,  // Low, heavy frequency
                    harmonics: 12,  // Many harsh harmonics
                    attack: 0.005,
                    filterType: 'lowpass',
                    filterFreq: 600,
                    filterQ: 4,
                    reverbMix: 0.4,
                    detune: 40,
                    // INDUSTRIAL MACHINERY - grinding metal, mechanical hits, heavy distortion
                    useMetalGrind: true,
                    grindIntensity: 1.2,
                    grindModulation: 8.0,  // Fast modulation for grinding texture
                    useHeavyDistortion: true,
                    distortionDrive: 6.0,  // Heavy overdrive
                    useMetalHits: true,  // Percussive metal impacts
                    metalHitCount: 15,
                    metalHitVolume: 0.8,
                    useGrindNoise: true,  // Harsh noise layer
                    grindNoiseRatio: 1.5,
                    useLowRumble: true,  // Deep machinery rumble
                    rumbleFreq: 0.3
                }
            }
        ];

        let selectedColorIndex = -1;
        let currentDynamicColor = { r: 0.56, g: 0.57, b: 0.62 };
        let currentDiffusion = 0.3;

        // ===== GLITCH EFFECTS SYSTEM =====
        const glitchEffects = {
            bitCrush: { active: false, name: 'Bit Crush', icon: '◼' },
            corrupt: { active: false, name: 'Corrupt', icon: '◆' },
            feedback: { active: false, name: 'Feedback', icon: '↻' },
            rgbSplit: { active: false, name: 'RGB Split', icon: '▣' },
            freeze: { active: false, name: 'Freeze', icon: '❄' }
        };
        
        let glitchState = {
            bitCrushDepth: 4,
            corruptionRate: 0.05,
            feedbackAmount: 0.3,
            rgbSplitAmount: 0.01,
            freezeFrame: null,
            pixelSize: 32,  // EXTREME: Much larger pixels
            prismLayers: 5
        };

        // ===== MUSICAL QUANTIZATION SYSTEM =====
        
        /*
         * WHAT IS QUANTIZATION?
         * --------------------
         * Quantization "snaps" frequencies to real musical notes, like snapping to a grid.
         * Instead of playing 442Hz (slightly out of tune), it rounds to 440Hz (perfect A note).
         * 
         * WHY A440 STANDARD?
         * - A440 means the note "A above middle C" vibrates at exactly 440 times per second
         * - This is the universal tuning standard used by orchestras and musicians worldwide
         * - All other notes are calculated relative to this anchor point
         * 
         * EQUAL TEMPERAMENT:
         * - Each half-step (semitone) multiplies frequency by 2^(1/12) ≈ 1.059463
         * - There are 12 semitones in an octave
         * - Doubling frequency = going up one octave (A220 → A440 → A880)
         */
        
        // Note names for reference (C0 = MIDI note 12, A4 = MIDI note 69 = 440Hz)
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Musical scales as intervals from root note (in semitones)
        const SCALES = {
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],  // All 12 notes
            major: [0, 2, 4, 5, 7, 9, 11],  // Happy, bright (Do-Re-Mi-Fa-Sol-La-Ti)
            minor: [0, 2, 3, 5, 7, 8, 10],  // Sad, emotional
            pentatonic: [0, 2, 4, 7, 9],    // Can't play a wrong note! (black keys on piano)
            blues: [0, 3, 5, 6, 7, 10],     // Bluesy, soulful
            dorian: [0, 2, 3, 5, 7, 9, 10]  // Jazzy, sophisticated
        };
        
        // Current musical settings
        let musicalSettings = {
            rootNote: 60,        // Middle C (MIDI note 60 = 261.63Hz)
            scale: 'pentatonic', // Start with pentatonic - easiest to sound good!
            octaveRange: 3       // How many octaves we can span
        };
        
        /**
         * Convert MIDI note number to frequency in Hz
         * Formula: freq = 440 * 2^((midiNote - 69) / 12)
         * Where 69 is the MIDI number for A440
         */
        function midiToFreq(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
        
        /**
         * Convert frequency to nearest MIDI note number
         */
        function freqToMidi(freq) {
            return Math.round(69 + 12 * Math.log2(freq / 440));
        }
        
        /**
         * QUANTIZE FREQUENCY TO MUSICAL NOTE
         * This is the core function that makes frequencies musical!
         * 
         * @param {number} rawFreq - Any frequency (could be off-tune)
         * @param {string} scaleName - Which scale to use (pentatonic, major, etc.)
         * @param {number} rootNote - Root note of the scale (MIDI number)
         * @returns {number} - Quantized frequency that fits the scale
         */
        function quantizeToScale(rawFreq, scaleName = 'pentatonic', rootNote = 60) {
            // 1. Convert the raw frequency to a MIDI note number
            const rawMidi = freqToMidi(rawFreq);
            
            // 2. Get the scale intervals
            const scale = SCALES[scaleName] || SCALES.pentatonic;
            
            // 3. Find which octave we're in relative to the root
            const noteInOctave = ((rawMidi - rootNote) % 12 + 12) % 12;
            const octaveOffset = Math.floor((rawMidi - rootNote) / 12);
            
            // 4. Find the closest note in the scale
            let closestInterval = scale[0];
            let minDistance = Math.abs(noteInOctave - closestInterval);
            
            for (let interval of scale) {
                const distance = Math.abs(noteInOctave - interval);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestInterval = interval;
                }
            }
            
            // 5. Calculate the final MIDI note (in the correct octave)
            const quantizedMidi = rootNote + octaveOffset * 12 + closestInterval;
            
            // 6. Convert back to frequency
            return midiToFreq(quantizedMidi);
        }

        // ===== MUSICAL RHYTHM SYSTEM =====
        
        /*
         * MUSICAL TIME EXPLAINED:
         * ----------------------
         * Music is organized into beats and subdivisions:
         * 
         * TEMPO (BPM) = Beats Per Minute
         * - 120 BPM means 120 quarter notes per minute = 2 per second
         * - Standard dance music: 120-130 BPM
         * - Standard hip-hop: 80-100 BPM
         * 
         * NOTE DIVISIONS:
         * - Whole note = 4 beats (very slow)
         * - Half note = 2 beats
         * - Quarter note = 1 beat (the "pulse" of the song)
         * - Eighth note = 0.5 beats (twice as fast)
         * - Sixteenth note = 0.25 beats (four times as fast)
         * 
         * TIME SIGNATURE:
         * - 4/4 means: 4 beats per measure, quarter note gets the beat
         * - Most common in Western music
         */
        
        // Master musical clock
        let musicalClock = {
            bpm: 120,              // Master tempo (beats per minute)
            isPlaying: false,
            startTime: 0,          // When the clock started
            currentBeat: 0,        // Which beat we're on
            beatsPerBar: 4,        // Time signature (4/4 time)
            audioContext: null
        };
        
        /**
         * Calculate interval in milliseconds for a given note division
         * @param {number} division - 1 = quarter note, 0.5 = eighth, 0.25 = sixteenth, 2 = half
         */
        function getMusicalInterval(division) {
            const quarterNoteMs = (60 / musicalClock.bpm) * 1000;
            return quarterNoteMs * division;
        }
        
        // Beat system with MUSICAL subdivisions instead of random BPMs
        const beatEffects = {
            // Kick = Quarter notes (on the beat: 1, 2, 3, 4)
            kick: { 
                active: false, 
                name: 'Kick', 
                icon: '●', 
                division: 1.0,     // Plays every quarter note
                interval: null,
                description: 'Quarter notes - on every beat'
            },
            // Hi-hat = Eighth notes (twice as fast: 1-and-2-and-3-and-4-and)
            hihat: { 
                active: false, 
                name: 'Hi-Hat', 
                icon: '×', 
                division: 0.5,     // Plays every eighth note
                interval: null,
                description: 'Eighth notes - double time'
            },
            // Snare = Half notes (on beats 2 and 4 - the "backbeat")
            snare: { 
                active: false, 
                name: 'Snare', 
                icon: '▬', 
                division: 2.0,     // Plays every half note
                interval: null,
                skipFirstBeat: true, // Skip beat 1, play on beat 3 for that backbeat feel
                description: 'Backbeat - on beats 2 & 4'
            },
            // Pulse = Whole notes (every 4 beats - very slow)
            pulse: { 
                active: false, 
                name: 'Pulse', 
                icon: '◉', 
                division: 4.0,     // Plays every whole note (once per bar)
                interval: null,
                description: 'Whole notes - once per bar'
            }
        };

        function initColorPalette() {
            const palette = document.getElementById('colorPalette');
            colorVoices.forEach((voice, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.background = voice.hex;
                swatch.title = `Color voice ${index + 1}`;
                swatch.addEventListener('click', () => selectColor(index));
                palette.appendChild(swatch);
            });
        }

        function selectColor(index) {
            selectedColorIndex = index;
            document.querySelectorAll('.color-swatch').forEach((swatch, i) => {
                swatch.classList.toggle('selected', i === index);
            });
            
            const voice = colorVoices[index];
            currentDynamicColor = voice.color;
            currentDiffusion = voice.diffusion;
        }

        // ===== GLITCH FUNCTIONS =====
        
        function initGlitchPanel() {
            const palette = document.getElementById('colorPalette');
            
            // Add divider
            const divider = document.createElement('div');
            divider.className = 'glitch-divider';
            palette.appendChild(divider);
            
            // Add glitch buttons
            Object.keys(glitchEffects).forEach((key) => {
                const effect = glitchEffects[key];
                const btn = document.createElement('button');
                btn.className = 'glitch-btn';
                btn.innerHTML = effect.icon;
                btn.dataset.glitch = key;
                btn.title = effect.name;
                btn.addEventListener('click', () => toggleGlitch(key, btn));
                palette.appendChild(btn);
            });
        }
        
        function toggleGlitch(key, btn) {
            glitchEffects[key].active = !glitchEffects[key].active;
            btn.classList.toggle('active', glitchEffects[key].active);
        }
        
        // ===== BEAT FUNCTIONS =====
        
        function initBeatPanel() {
            const palette = document.getElementById('colorPalette');
            
            // Add divider
            const divider = document.createElement('div');
            divider.className = 'glitch-divider';
            palette.appendChild(divider);
            
            // Add beat buttons with MUSICAL descriptions
            Object.keys(beatEffects).forEach((key) => {
                const effect = beatEffects[key];
                const btn = document.createElement('button');
                btn.className = 'beat-btn';
                btn.innerHTML = effect.icon;
                btn.dataset.beat = key;
                // Show musical timing instead of arbitrary BPM
                btn.title = `${effect.name} - ${effect.description}`;
                btn.addEventListener('click', () => toggleBeat(key, btn));
                palette.appendChild(btn);
            });
        }
        
        function toggleBeat(key, btn) {
            const beat = beatEffects[key];
            beat.active = !beat.active;
            btn.classList.toggle('active', beat.active);
            
            if (beat.active) {
                startBeat(key, btn);
            } else {
                stopBeat(key);
            }
        }
        
        function startBeat(key, btn) {
            const beat = beatEffects[key];
            
            /*
             * MUSICAL TIMING:
             * Instead of using arbitrary BPM values, we calculate the interval
             * based on musical note divisions (quarter, eighth, etc.)
             * 
             * For example:
             * - If BPM = 120, one quarter note = 500ms
             * - Eighth note (division 0.5) = 250ms
             * - Half note (division 2.0) = 1000ms
             * 
             * This ensures all beats are musically related!
             */
            const intervalMs = getMusicalInterval(beat.division);
            
            // Trigger immediately
            triggerBeat(key, btn);
            
            // Set up interval using musical timing
            beat.interval = setInterval(() => {
                triggerBeat(key, btn);
            }, intervalMs);
        }
        
        function stopBeat(key) {
            const beat = beatEffects[key];
            if (beat.interval) {
                clearInterval(beat.interval);
                beat.interval = null;
            }
        }
        
        function triggerBeat(key, btn) {
            // Visual pulse on button
            btn.classList.remove('pulse');
            setTimeout(() => btn.classList.add('pulse'), 10);
            
            // Create visual splat
            createBeatSplat(key);
            
            // Create audio
            if (audioEnabled && audioContext) {
                createBeatSound(key);
            }
        }
        
        function createBeatSplat(key) {
            if (!gl || !splatProgram) return;
            
            const positions = {
                kick: { x: 0.5, y: 0.2 },    // Bottom center
                hihat: { x: 0.8, y: 0.8 },   // Top right
                snare: { x: 0.5, y: 0.5 },   // Center
                pulse: { x: 0.2, y: 0.8 }    // Top left
            };
            
            const pos = positions[key];
            const splatX = pos.x + (Math.random() - 0.5) * 0.1;
            const splatY = pos.y + (Math.random() - 0.5) * 0.1;
            
            // Velocity splat
            gl.useProgram(splatProgram);
            const posLoc = gl.getAttribLocation(splatProgram, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            
            bindFramebuffer(velocity.write);
            gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
            gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
            gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), splatX, splatY);
            
            const angle = Math.random() * Math.PI * 2;
            const force = key === 'kick' ? 20.0 : key === 'snare' ? 15.0 : key === 'hihat' ? 8.0 : 12.0;
            
            gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'),
                Math.cos(angle) * force,
                Math.sin(angle) * force,
                0.0
            );
            gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'),
                key === 'kick' ? 0.015 : key === 'pulse' ? 0.012 : 0.008
            );
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            velocity.swap();
        }
        
        function createBeatSound(key) {
            const now = audioContext.currentTime;
            
            /*
             * MUSICAL BEAT SOUNDS:
             * Instead of random frequencies, beats now use musical notes
             * based on the current scale and root note.
             * This makes the rhythm section harmonize with the melodies!
             */
            
            if (key === 'kick') {
                /*
                 * KICK DRUM:
                 * - Uses the ROOT NOTE as its pitch (the foundation)
                 * - Drops down one octave for deep bass (-12 semitones)
                 * - Pitch slides down for that classic "thump" sound
                 */
                const rootFreq = midiToFreq(musicalSettings.rootNote - 12);  // One octave below root
                
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = rootFreq;
                osc.frequency.exponentialRampToValueAtTime(rootFreq * 0.5, now + 0.1);  // Slide down
                
                const env = audioContext.createGain();
                env.gain.value = 0.4;
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                osc.connect(env);
                env.connect(masterGain);
                osc.start(now);
                osc.stop(now + 0.3);
                
            } else if (key === 'hihat') {
                /*
                 * HI-HAT:
                 * - Pure noise (not pitched)
                 * - High frequency for crisp, bright sound
                 * - Very short duration for tight rhythm
                 */
                const bufferSize = audioContext.sampleRate * 0.05;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 8000;
                
                const env = audioContext.createGain();
                env.gain.value = 0.15;
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                
                noise.connect(filter);
                filter.connect(env);
                env.connect(masterGain);
                noise.start(now);
                
            } else if (key === 'snare') {
                /*
                 * SNARE:
                 * - Uses the FIFTH note of the scale (7 semitones up)
                 * - The "fifth" is super stable and supportive in music
                 * - Combines tone + noise for that classic snare "crack"
                 */
                const fifthFreq = midiToFreq(musicalSettings.rootNote + 7);  // Perfect fifth
                
                const osc = audioContext.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = fifthFreq;
                
                const oscEnv = audioContext.createGain();
                oscEnv.gain.value = 0.2;
                oscEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                
                // Noise component for "crack"
                const bufferSize = audioContext.sampleRate * 0.1;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const noiseEnv = audioContext.createGain();
                noiseEnv.gain.value = 0.3;
                noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                osc.connect(oscEnv);
                oscEnv.connect(masterGain);
                noise.connect(noiseEnv);
                noiseEnv.connect(masterGain);
                
                osc.start(now);
                osc.stop(now + 0.15);
                noise.start(now);
                
            } else if (key === 'pulse') {
                /*
                 * PULSE:
                 * - Uses the ROOT NOTE at its natural octave
                 * - Soft, sustained tone that grounds the harmony
                 * - With reverb for spacious, ambient feel
                 */
                const rootFreq = midiToFreq(musicalSettings.rootNote);
                
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = rootFreq;
                
                const env = audioContext.createGain();
                env.gain.value = 0.08;
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                osc.connect(env);
                env.connect(convolver);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        }
        
        // Apply audio glitches to the color voice audio nodes
        function applyAudioGlitches(audioNodes) {
            if (!audioContext || !audioNodes) return audioNodes;
            
            let output = audioNodes.output;
            const cursorVelocity = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
            
            // Bit Crusher - EXTREME audio bit crushing
            if (glitchEffects.bitCrush.active) {
                const bitCrusher = audioContext.createWaveShaper();
                const curve = new Float32Array(256);
                // EXTREME: Much more aggressive bit depth
                const dynamicDepth = Math.max(1, glitchState.bitCrushDepth - cursorVelocity * 30);
                const step = Math.pow(2, dynamicDepth);
                for (let i = 0; i < 256; i++) {
                    const x = (i / 128) - 1;
                    const crushed = Math.round(x * step) / step;
                    // Add random glitch artifacts (5% chance of corruption)
                    curve[i] = Math.random() < 0.95 ? crushed : crushed * (Math.random() * 2 - 1);
                }
                bitCrusher.curve = curve;
                
                // Add distortion for more aggressive sound
                const distortion = audioContext.createWaveShaper();
                const distCurve = new Float32Array(256);
                for (let i = 0; i < 256; i++) {
                    const x = (i / 128) - 1;
                    distCurve[i] = Math.tanh(x * 3); // Heavy distortion
                }
                distortion.curve = distCurve;
                
                output.connect(bitCrusher);
                bitCrusher.connect(distortion);
                output = distortion;
            }
            
            // Feedback - cursor speed controls feedback amount
            if (glitchEffects.feedback.active) {
                const feedbackDelay = audioContext.createDelay();
                const feedbackGain = audioContext.createGain();
                // Cursor position controls delay time
                feedbackDelay.delayTime.value = 0.05 + mouseY * 0.15;
                // Cursor velocity controls feedback intensity
                feedbackGain.gain.value = glitchState.feedbackAmount * (1 + cursorVelocity * 2);
                
                output.connect(feedbackDelay);
                feedbackDelay.connect(feedbackGain);
                feedbackGain.connect(feedbackDelay);
                output = feedbackDelay;
            }
            
            // Corrupt - cursor position triggers corruption
            if (glitchEffects.corrupt.active) {
                // More corruption near edges and with fast movement
                const edgeProximity = Math.max(
                    Math.abs(mouseX - 0.5),
                    Math.abs(mouseY - 0.5)
                ) * 2;
                const corruptChance = glitchState.corruptionRate * (1 + edgeProximity + cursorVelocity * 5);
                
                if (Math.random() < corruptChance) {
                    audioNodes.oscillators.forEach(osc => {
                        if (osc && osc.frequency) {
                            const jump = Math.random() > 0.5 ? 2 : 0.5;
                            osc.frequency.setValueAtTime(osc.frequency.value * jump, audioContext.currentTime);
                            osc.frequency.exponentialRampToValueAtTime(osc.frequency.value / jump, audioContext.currentTime + 0.05);
                        }
                    });
                }
            }
            
            // RGB Split - affects audio panning based on cursor position
            if (glitchEffects.rgbSplit.active && audioNodes.panner) {
                // Cursor X position controls extreme panning
                const panAmount = (mouseX - 0.5) * 3; // Exaggerated panning
                audioNodes.panner.pan.value = Math.max(-1, Math.min(1, panAmount));
            }
            
            // Freeze - freezes at cursor position
            if (glitchEffects.freeze.active) {
                if (!glitchState.freezeFrame) {
                    // Freeze based on cursor Y position
                    const freezeFreq = 200 + mouseY * 1000;
                    glitchState.freezeFrame = {
                        frequency: freezeFreq,
                        time: audioContext.currentTime
                    };
                    // Apply frozen frequency
                    audioNodes.oscillators.forEach(osc => {
                        if (osc && osc.frequency) {
                            osc.frequency.setValueAtTime(freezeFreq, audioContext.currentTime);
                        }
                    });
                }
            } else {
                glitchState.freezeFrame = null;
            }
            
            return { ...audioNodes, output };
        }
        
        // Apply visual glitches to the fluid simulation
        function applyVisualGlitches() {
            // Reset color and diffusion to base values (fixes color drift bug)
            if (selectedColorIndex >= 0) {
                const voice = colorVoices[selectedColorIndex];
                currentDynamicColor = { ...voice.color };
                currentDiffusion = voice.diffusion;
            }
            
            // Bit Crush - EXTREME PIXELATION EFFECT with color quantization
            if (glitchEffects.bitCrush.active) {
                // EXTREME: Dramatically reduce diffusion for super blocky effect
                currentDiffusion *= 0.15; // Much more blocky than before
                
                // COLOR QUANTIZATION - reduce to limited color palette (like 8-bit graphics)
                if (selectedColorIndex >= 0) {
                    const voice = colorVoices[selectedColorIndex];
                    const colorLevels = 4; // Only 4 shades per channel = 64 total colors
                    currentDynamicColor.r = Math.floor(voice.color.r * colorLevels) / colorLevels;
                    currentDynamicColor.g = Math.floor(voice.color.g * colorLevels) / colorLevels;
                    currentDynamicColor.b = Math.floor(voice.color.b * colorLevels) / colorLevels;
                }
                
                // Create MULTIPLE pixelated splats constantly for extreme effect
                const numSplats = 3; // Multiple splats per frame
                for (let i = 0; i < numSplats; i++) {
                    const gridSize = glitchState.pixelSize;
                    
                    // Snap to pixel grid with random offset for glitchy look
                    const offsetX = (Math.random() > 0.8) ? (1 / gridSize) : 0;
                    const offsetY = (Math.random() > 0.8) ? (1 / gridSize) : 0;
                    const gridX = Math.floor(mouseX * gridSize) / gridSize + (0.5 / gridSize) + offsetX;
                    const gridY = Math.floor(mouseY * gridSize) / gridSize + (0.5 / gridSize) + offsetY;
                    
                    // Velocity splat - HUGE radius for massive pixels
                    gl.useProgram(splatProgram);
                    const posLoc = gl.getAttribLocation(splatProgram, 'position');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(velocity.write);
                    gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), gridX, gridY);
                    gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                        mouseVelX * 5, mouseVelY * 5, 0.0
                    );
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.04); // HUGE pixels
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    velocity.swap();
                    
                    // Pixelated color splats with quantized colors
                    if (selectedColorIndex >= 0 && colorSplatProgram) {
                        const voice = colorVoices[selectedColorIndex];
                        
                        gl.useProgram(colorSplatProgram);
                        const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                        gl.enableVertexAttribArray(colorPosLoc);
                        gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                        
                        bindFramebuffer(colorBuffer.write);
                        gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                        gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), gridX, gridY);
                        
                        // Quantized colors (limited palette like old video games)
                        const levels = 4;
                        const r = Math.floor(voice.color.r * levels) / levels;
                        const g = Math.floor(voice.color.g * levels) / levels;
                        const b = Math.floor(voice.color.b * levels) / levels;
                        
                        gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                            r * 0.7, 
                            g * 0.7, 
                            b * 0.7
                        );
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.035); // HUGE color blocks
                        
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        colorBuffer.swap();
                    }
                }
                
                // GLITCH ARTIFACTS - random pixel corruption
                if (Math.random() < 0.2) {
                    const gridSize = glitchState.pixelSize;
                    const randomX = Math.floor(Math.random() * gridSize) / gridSize;
                    const randomY = Math.floor(Math.random() * gridSize) / gridSize;
                    
                    gl.useProgram(splatProgram);
                    const posLoc = gl.getAttribLocation(splatProgram, 'position');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(velocity.write);
                    gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), randomX, randomY);
                    gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                        (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, 0.0
                    );
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.02);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    velocity.swap();
                }
            }
            
            // Corrupt - chaos radiating from cursor + COLOR INVERSION
            if (glitchEffects.corrupt.active) {
                // Invert colors based on cursor proximity and movement
                const cursorVelocity = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
                if (selectedColorIndex >= 0 && cursorVelocity > 0.01) {
                    const voice = colorVoices[selectedColorIndex];
                    // Invert colors: subtract from 1.0
                    currentDynamicColor.r = 1.0 - voice.color.r;
                    currentDynamicColor.g = 1.0 - voice.color.g;
                    currentDynamicColor.b = 1.0 - voice.color.b;
                }
                
                // Spawn corruption near cursor
                if (Math.random() < glitchState.corruptionRate * 3) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 0.2;
                    const x = mouseX + Math.cos(angle) * dist;
                    const y = mouseY + Math.sin(angle) * dist;
                    const force = 8 + Math.random() * 15;
                    
                    gl.useProgram(splatProgram);
                    const posLoc = gl.getAttribLocation(splatProgram, 'position');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(velocity.write);
                    gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), x, y);
                    gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                        Math.cos(angle) * force, 
                        Math.sin(angle) * force, 
                        0.0
                    );
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.002 + Math.random() * 0.008);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    velocity.swap();
                    
                    // Inject inverted color splats at corruption points
                    if (selectedColorIndex >= 0 && colorSplatProgram) {
                        const voice = colorVoices[selectedColorIndex];
                        
                        gl.useProgram(colorSplatProgram);
                        const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                        gl.enableVertexAttribArray(colorPosLoc);
                        gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                        
                        bindFramebuffer(colorBuffer.write);
                        gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                        gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), x, y);
                        
                        // INVERTED colors at corruption points
                        gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                            (1.0 - voice.color.r) * 0.8,
                            (1.0 - voice.color.g) * 0.8,
                            (1.0 - voice.color.b) * 0.8
                        );
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.004);
                        
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        colorBuffer.swap();
                    }
                }
            }
            
            // RGB Split - PRISM EFFECT with multiple color layers (cursor-responsive)
            if (glitchEffects.rgbSplit.active && selectedColorIndex >= 0 && colorSplatProgram) {
                const voice = colorVoices[selectedColorIndex];
                const cursorInfluence = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
                
                // Create multiple color layers (prism effect)
                for (let i = 0; i < glitchState.prismLayers; i++) {
                    const angle = (i / glitchState.prismLayers) * Math.PI * 2;
                    const offset = glitchState.rgbSplitAmount * (1 + cursorInfluence * 5);
                    const splitX = mouseX + Math.cos(angle) * offset;
                    const splitY = mouseY + Math.sin(angle) * offset;
                    
                    // Shift hue for each layer
                    const hueShift = i / glitchState.prismLayers;
                    const r = voice.color.r * (1 - hueShift) + hueShift;
                    const g = voice.color.g * (1 - hueShift * 0.5) + hueShift * 0.5;
                    const b = voice.color.b * (1 - hueShift * 0.3) + hueShift * 0.7;
                    
                    gl.useProgram(colorSplatProgram);
                    const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                    gl.enableVertexAttribArray(colorPosLoc);
                    gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(colorBuffer.write);
                    gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), splitX, splitY);
                    gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), r * 0.3, g * 0.3, b * 0.3);
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.002);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    colorBuffer.swap();
                }
            }
            
            // Feedback - trails following cursor path
            if (glitchEffects.feedback.active) {
                const velocity = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
                currentDiffusion *= 1.2 + velocity * 2; // Stronger trails when moving fast
            }
            
            // Freeze - DARKENS entire fluid + freezes motion at cursor
            if (glitchEffects.freeze.active) {
                // DARKEN the entire fluid - creates frozen/crystallized appearance
                if (selectedColorIndex >= 0) {
                    const voice = colorVoices[selectedColorIndex];
                    // Dramatically darken colors (multiply by 0.3 = 70% darker)
                    currentDynamicColor.r = voice.color.r * 0.3;
                    currentDynamicColor.g = voice.color.g * 0.3;
                    currentDynamicColor.b = voice.color.b * 0.3;
                    
                    // Add icy blue tint
                    currentDynamicColor.b += 0.1;
                }
                
                // Reduce diffusion for sharper, frozen texture
                currentDiffusion *= 0.4;
                
                // Create freeze effect at cursor - counter-velocity to stop motion
                gl.useProgram(splatProgram);
                const posLoc = gl.getAttribLocation(splatProgram, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                bindFramebuffer(velocity.write);
                gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), mouseX, mouseY);
                gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                    -mouseVelX * 0.5, -mouseVelY * 0.5, 0.0 // Counter-velocity
                );
                gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.05);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                velocity.swap();
                
                // Inject dark frozen color splats around cursor
                if (selectedColorIndex >= 0 && colorSplatProgram) {
                    const voice = colorVoices[selectedColorIndex];
                    
                    gl.useProgram(colorSplatProgram);
                    const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                    gl.enableVertexAttribArray(colorPosLoc);
                    gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(colorBuffer.write);
                    gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), mouseX, mouseY);
                    
                    // Dark frozen colors with blue tint
                    gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                        voice.color.r * 0.2,
                        voice.color.g * 0.2,
                        voice.color.b * 0.3 + 0.1 // Blue tint
                    );
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.01);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    colorBuffer.swap();
                }
            }
        }

        const vertexShaderSource = `
            attribute vec2 position;
            varying vec2 vUv;
            void main() {
                vUv = position * 0.5 + 0.5;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const advectionShaderSource = `
            precision mediump float;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform float dt;
            uniform float dissipation;
            varying vec2 vUv;
            
            void main() {
                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                gl_FragColor = dissipation * texture2D(uSource, coord);
            }
        `;

        const diffusionShaderSource = `
            precision mediump float;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform float diffusionRate;
            varying vec2 vUv;
            
            void main() {
                // Diffusion creates organic spreading like ink in water
                vec3 center = texture2D(uSource, vUv).rgb;
                vec3 left = texture2D(uSource, vUv - vec2(texelSize.x, 0.0)).rgb;
                vec3 right = texture2D(uSource, vUv + vec2(texelSize.x, 0.0)).rgb;
                vec3 top = texture2D(uSource, vUv + vec2(0.0, texelSize.y)).rgb;
                vec3 bottom = texture2D(uSource, vUv - vec2(0.0, texelSize.y)).rgb;
                
                // Laplacian diffusion - creates natural spreading
                vec3 laplacian = left + right + top + bottom - 4.0 * center;
                vec3 diffused = center + laplacian * diffusionRate;
                
                gl_FragColor = vec4(diffused, 1.0);
            }
        `;

        const divergenceShaderSource = `
            precision mediump float;
            uniform sampler2D uVelocity;
            uniform vec2 texelSize;
            varying vec2 vUv;
            
            void main() {
                float L = texture2D(uVelocity, vUv - vec2(texelSize.x, 0.0)).x;
                float R = texture2D(uVelocity, vUv + vec2(texelSize.x, 0.0)).x;
                float T = texture2D(uVelocity, vUv + vec2(0.0, texelSize.y)).y;
                float B = texture2D(uVelocity, vUv - vec2(0.0, texelSize.y)).y;
                
                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `;

        const pressureShaderSource = `
            precision mediump float;
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;
            uniform vec2 texelSize;
            varying vec2 vUv;
            
            void main() {
                float L = texture2D(uPressure, vUv - vec2(texelSize.x, 0.0)).x;
                float R = texture2D(uPressure, vUv + vec2(texelSize.x, 0.0)).x;
                float T = texture2D(uPressure, vUv + vec2(0.0, texelSize.y)).x;
                float B = texture2D(uPressure, vUv - vec2(0.0, texelSize.y)).x;
                float C = texture2D(uDivergence, vUv).x;
                
                gl_FragColor = vec4((L + R + B + T - C) * 0.25, 0.0, 0.0, 1.0);
            }
        `;

        const gradientSubtractShaderSource = `
            precision mediump float;
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;
            uniform vec2 texelSize;
            varying vec2 vUv;
            
            void main() {
                float L = texture2D(uPressure, vUv - vec2(texelSize.x, 0.0)).x;
                float R = texture2D(uPressure, vUv + vec2(texelSize.x, 0.0)).x;
                float T = texture2D(uPressure, vUv + vec2(0.0, texelSize.y)).x;
                float B = texture2D(uPressure, vUv - vec2(0.0, texelSize.y)).x;
                
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity.xy -= vec2(R - L, T - B) * 0.5;
                
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `;

        const splatShaderSource = `
            precision mediump float;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec2 point;
            uniform vec3 color;
            uniform float radius;
            varying vec2 vUv;
            
            void main() {
                vec2 p = vUv - point;
                p.x *= aspectRatio;
                
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `;

        const colorSplatShaderSource = `
            precision mediump float;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec2 point;
            uniform vec3 color;
            uniform float radius;
            varying vec2 vUv;
            
            void main() {
                vec2 p = vUv - point;
                p.x *= aspectRatio;
                
                float dist = length(p);
                
                // Concentrated ink drop - small, intense center
                float intensity = exp(-dist * dist / (radius * 0.3));
                
                vec3 splat = color * intensity;
                vec4 base = texture2D(uTarget, vUv);
                
                // Add ink drop
                vec3 newColor = base.rgb + splat;
                newColor = clamp(newColor, 0.0, 1.0);
                
                gl_FragColor = vec4(newColor, 1.0);
            }
        `;

        const displayShaderSource = `
            precision mediump float;
            uniform sampler2D uVelocity;
            uniform sampler2D uColor;
            uniform float time;
            uniform vec2 resolution;
            varying vec2 vUv;
            
            const float PI = 3.141592654;
            const float scale = 0.25;
            const vec4 a = vec4(4.5, 6.0, 8.0, 11.0);
            const vec2 b = vec2(1.0, 1.0);
            
            const vec3 baseColor1 = vec3(0.95);
            const vec3 baseColor2 = vec3(0.66, 0.67, 0.70);
            const vec3 baseColor3 = vec3(0.35, 0.37, 0.42);
            const vec3 baseColor4 = vec3(0.56, 0.57, 0.62);
            
            float cheapNoise(vec3 p) {
                float s1 = sin(p.z + p.x * a.x + cos(p.x * a.x - p.z));
                float c1 = cos(p.z + p.y * a.y + cos(p.y * a.x + p.z));
                float s2 = sin(1.0 + p.x * a.z + p.z + cos(p.y * a.w - p.z));
                float c2 = cos(1.0 + p.y * a.w + p.z + cos(p.x * a.x + p.z));
                return s1 * c1 * 0.564 + s2 * c2 * 0.436;
            }
            
            void main() {
                vec2 aR = vec2(resolution.x / resolution.y, 1.0);
                vec2 st = vUv * aR * scale;
                
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                vec3 inkColor = texture2D(uColor, vUv).rgb;
                float inkPresence = length(inkColor);
                
                vec2 fluidDistortion = velocity * 3.0;
                
                float t = time * 0.008;
                float S = sin(t);
                float C = cos(t);
                
                vec3 stMod = vec3(st + fluidDistortion * 0.5, 0.0);
                
                vec2 v1 = vec2(
                    cheapNoise(stMod + vec3(0.0, 0.0, 2.0)),
                    cheapNoise(stMod + vec3(0.0, 0.0, 1.0))
                );
                
                vec2 offset1 = vec2(C * 1.7, S * 9.2) + fluidDistortion * 0.3;
                vec2 offset2 = vec2(S * 8.3, C * 2.8) + fluidDistortion * 0.3;
                
                vec2 v2 = vec2(
                    cheapNoise(vec3(st + b.x * v1 + offset1, 0.12 * time)),
                    cheapNoise(vec3(st + b.y * v1 + offset2, 0.10 * time))
                );
                
                float n = 0.5 + 0.5 * cheapNoise(vec3(st + v2 + fluidDistortion * 0.2, 0.0));
                float nn = n * n;
                
                // Generate base metallic grey
                vec3 metallic = mix(baseColor1, baseColor2, clamp(nn * 8.0, 0.0, 1.0));
                metallic = mix(metallic, baseColor3, clamp(length(v1), 0.0, 1.0));
                metallic = mix(metallic, baseColor4, clamp(length(v2.x), 0.0, 1.0));
                
                float velocityMag = length(velocity);
                metallic += vec3(0.2) * velocityMag;
                metallic /= nn + n * 7.0;
                
                // Where ink is present, it colors the metallic liquid
                if (inkPresence > 0.05) {
                    // Normalize ink to get hue
                    vec3 inkHue = inkPresence > 0.0 ? inkColor / inkPresence : vec3(0.0);
                    
                    // Extract metallic luminosity structure
                    float lum = dot(metallic, vec3(0.299, 0.587, 0.114));
                    
                    // Tint the metallic with ink hue, preserving structure
                    vec3 tintedMetallic = inkHue * lum * 1.2;
                    
                    // Nearly full replacement - very opaque
                    float blend = smoothstep(0.05, 0.3, inkPresence) * 0.95;
                    metallic = mix(metallic, tintedMetallic, blend);
                }
                
                // Prevent extreme whites
                metallic = clamp(metallic, 0.0, 0.7);
                
                gl_FragColor = vec4(metallic, 1.0);
            }
        `;

        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(vertSource, fragSource) {
            const vertShader = compileShader(gl.VERTEX_SHADER, vertSource);
            const fragShader = compileShader(gl.FRAGMENT_SHADER, fragSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }

        const advectionProgram = createProgram(vertexShaderSource, advectionShaderSource);
        const diffusionProgram = createProgram(vertexShaderSource, diffusionShaderSource);
        const divergenceProgram = createProgram(vertexShaderSource, divergenceShaderSource);
        const pressureProgram = createProgram(vertexShaderSource, pressureShaderSource);
        const gradientSubtractProgram = createProgram(vertexShaderSource, gradientSubtractShaderSource);
        const splatProgram = createProgram(vertexShaderSource, splatShaderSource);
        const colorSplatProgram = createProgram(vertexShaderSource, colorSplatShaderSource);
        const displayProgram = createProgram(vertexShaderSource, displayShaderSource);

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        function createFramebuffer(width, height) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);
            
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            
            return { fbo, texture, width, height };
        }

        function createDoubleFBO(width, height) {
            return {
                read: createFramebuffer(width, height),
                write: createFramebuffer(width, height),
                swap: function() {
                    const temp = this.read;
                    this.read = this.write;
                    this.write = temp;
                }
            };
        }

        const velocity = createDoubleFBO(simWidth, simHeight);
        const divergence = createFramebuffer(simWidth, simHeight);
        const pressure = createDoubleFBO(simWidth, simHeight);
        const colorBuffer = createDoubleFBO(simWidth, simHeight);

        // Initialize color buffer to completely empty
        gl.viewport(0, 0, simWidth, simHeight);
        gl.bindFramebuffer(gl.FRAMEBUFFER, colorBuffer.read.fbo);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, colorBuffer.write.fbo);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // Mouse and interaction state
        let mouseX = 0.5;
        let mouseY = 0.5;
        let lastMouseX = 0.5;
        let lastMouseY = 0.5;
        let mouseVelX = 0;
        let mouseVelY = 0;
        let prevVelocityMag = 0;
        let acceleration = 0;
        let movementMomentum = 0;
        let areaConcentration = 0;
        let turbulence = 0;
        let recentPositions = [];
        let recentVelocities = [];
        let pendingClicks = [];
        const MAX_POSITIONS = 20;
        const MAX_VELOCITIES = 10;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX / rect.width;
            mouseY = 1.0 - e.clientY / rect.height;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX / rect.width;
            const clickY = 1.0 - e.clientY / rect.height;
            
            pendingClicks.push({ x: clickX, y: clickY });
            
            if (audioEnabled) {
                createSplashSound(clickX, clickY);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouseX = e.touches[0].clientX / rect.width;
            mouseY = 1.0 - e.touches[0].clientY / rect.height;
        }, { passive: false });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const clickX = e.touches[0].clientX / rect.width;
            const clickY = 1.0 - e.touches[0].clientY / rect.height;
            
            pendingClicks.push({ x: clickX, y: clickY });
            
            if (audioEnabled) {
                createSplashSound(clickX, clickY);
            }
        }, { passive: false });

        function bindFramebuffer(target) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
            gl.viewport(0, 0, target.width, target.height);
        }

        // ===== AUDIO ENGINE =====
        let audioContext = null;
        let audioEnabled = false;
        
        let masterGain;
        let convolver, convolverGain;
        let lastSoundTime = 0;
        let rootDrone, rootGain;
        let echoTone, echoGain, echoFilter;
        let lastColorIntensity = 0;
        
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioContext.destination);
            
            convolver = audioContext.createConvolver();
            convolverGain = audioContext.createGain();
            convolverGain.gain.value = 0.7;
            convolver.connect(convolverGain);
            convolverGain.connect(masterGain);
            
            /*
             * REVERB IMPULSE RESPONSE:
             * Creating a synthetic reverb that simulates sound bouncing in a space
             * - Longer length = bigger space (4 seconds = cathedral-like)
             * - The decay curve creates natural-sounding reflections
             */
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * 4;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            const impulseL = impulse.getChannelData(0);
            const impulseR = impulse.getChannelData(1);
            
            for (let i = 0; i < length; i++) {
                impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3.5);
                impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3.5);
            }
            convolver.buffer = impulse;
            
            /*
             * ROOT DRONE:
             * A subtle background tone that provides harmonic foundation
             * - Plays the ROOT NOTE of our scale
             * - Very quiet, just gives a sense of "key"
             */
            rootGain = audioContext.createGain();
            rootGain.gain.value = 0.0;
            
            rootDrone = audioContext.createOscillator();
            rootDrone.type = 'sine';
            rootDrone.frequency.value = midiToFreq(musicalSettings.rootNote - 12);  // Root note, one octave below
            
            const rootFilter = audioContext.createBiquadFilter();
            rootFilter.type = 'lowpass';
            rootFilter.frequency.value = 300;
            rootFilter.Q.value = 1;
            
            rootDrone.connect(rootFilter);
            rootFilter.connect(rootGain);
            rootGain.connect(convolver);
            rootDrone.start();
            
            /*
             * ECHO TONE:
             * A second drone playing the FIFTH (7 semitones up)
             * - The fifth is the most consonant interval after the octave
             * - Together with the root, creates a stable, open sound
             */
            echoGain = audioContext.createGain();
            echoGain.gain.value = 0.0;
            
            echoFilter = audioContext.createBiquadFilter();
            echoFilter.type = 'lowpass';
            echoFilter.frequency.value = 400;
            echoFilter.Q.value = 1.5;
            
            echoTone = audioContext.createOscillator();
            echoTone.type = 'sine';
            echoTone.frequency.value = midiToFreq(musicalSettings.rootNote - 5);  // Perfect fifth, one octave below
            
            echoTone.connect(echoFilter);
            echoFilter.connect(echoGain);
            echoGain.connect(convolver);
            echoTone.start();
            
            audioEnabled = true;
        }
        
        /**
         * QUANTIZE PITCH FROM MOUSE POSITION
         * This function converts cursor Y position into a musical note frequency
         * 
         * HOW IT WORKS:
         * 1. Y position maps to a range of octaves (set by musicalSettings.octaveRange)
         * 2. We calculate a continuous frequency across that range
         * 3. We quantize it to the nearest note in the selected scale
         * 4. Result: cursor movement = musical melody!
         * 
         * @param {number} mouseYPos - Cursor Y position (0 at top, 1 at bottom)
         * @returns {number} - Quantized frequency in Hz
         */
        function quantizePitch(mouseYPos) {
            /*
             * Map Y position to MIDI note range:
             * - Top of screen (y=0) = high notes
             * - Bottom of screen (y=1) = low notes
             * - Range spans musicalSettings.octaveRange octaves (3 by default)
             */
            const octaves = musicalSettings.octaveRange;
            const lowestNote = musicalSettings.rootNote - 12;  // One octave below root
            const highestNote = lowestNote + (octaves * 12);   // Three octaves up
            
            // Invert Y so top = high pitch, bottom = low pitch
            const normalizedY = 1 - mouseYPos;
            
            // Calculate the raw MIDI note (can be fractional, like 62.5)
            const rawMidiNote = lowestNote + (normalizedY * (highestNote - lowestNote));
            
            // Convert to frequency, then quantize to scale
            const rawFreq = midiToFreq(rawMidiNote);
            const quantizedFreq = quantizeToScale(rawFreq, musicalSettings.scale, musicalSettings.rootNote);
            
            return quantizedFreq;
        }

        // COLOR VOICE AUDIO TRIGGER
        function triggerColorVoice(voiceIndex, x, y, colorIntensity) {
            const voice = colorVoices[voiceIndex];
            const sound = voice.sound;
            const now = audioContext.currentTime;
            
            const baseFreq = quantizePitch(y) * sound.baseFreqMultiplier;
            const visualFadeTime = 5.0 * voice.persistence;
            const soundRelease = visualFadeTime * 0.8;
            const duration = sound.attack + soundRelease;
            
            const safeIntensity = Math.max(0, Math.min(colorIntensity || 0, 1.0));
            const baseVolume = 0.04 * Math.min(safeIntensity * 3, 1.0);
            
            if (!isFinite(baseVolume) || !isFinite(duration) || baseVolume <= 0) {
                return;
            }
            
            const osc = audioContext.createOscillator();
            osc.type = sound.waveform;
            osc.frequency.value = baseFreq;
            
            if (sound.detune) {
                osc.detune.value = (Math.random() - 0.5) * sound.detune;
            }
            
            if (sound.useModulation) {
                const lfo = audioContext.createOscillator();
                lfo.frequency.value = sound.modulationRate;
                const lfoGain = audioContext.createGain();
                lfoGain.gain.value = sound.modulationDepth;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start(now);
                lfo.stop(now + duration);
            }
            
            // SUB BASS for earthy rumble (brown)
            let subBass = null;
            let subBassEnv = null;
            if (sound.useSubBass) {
                subBass = audioContext.createOscillator();
                subBass.type = 'sine';
                subBass.frequency.value = baseFreq * sound.subBassFreq;
                
                subBassEnv = audioContext.createGain();
                subBassEnv.gain.value = 0;
                subBassEnv.gain.linearRampToValueAtTime(baseVolume * 0.8, now + 0.1);
                subBassEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                subBass.connect(subBassEnv);
            }
            
            // CRACKLE generator for organic texture (brown)
            let crackleNodes = [];
            if (sound.useCrackle) {
                const numCrackles = sound.crackleRate || 8;
                for (let i = 0; i < numCrackles; i++) {
                    const crackleDelay = Math.random() * duration * 0.9;
                    const crackleOsc = audioContext.createOscillator();
                    crackleOsc.type = Math.random() > 0.5 ? 'square' : 'sawtooth';
                    crackleOsc.frequency.value = 800 + Math.random() * 4000;
                    
                    const crackleEnv = audioContext.createGain();
                    crackleEnv.gain.value = 0;
                    crackleEnv.gain.setValueAtTime(0, now + crackleDelay);
                    const crackleVol = baseVolume * sound.crackleIntensity * (0.3 + Math.random() * 0.7);
                    crackleEnv.gain.linearRampToValueAtTime(crackleVol, now + crackleDelay + 0.002);
                    crackleEnv.gain.exponentialRampToValueAtTime(0.001, now + crackleDelay + 0.015);
                    
                    crackleOsc.connect(crackleEnv);
                    crackleNodes.push({ osc: crackleOsc, env: crackleEnv });
                }
            }
            
            // RUMBLE - chaotic low frequency movement (brown)
            let rumbleOsc = null;
            let rumbleEnv = null;
            if (sound.useRumble) {
                rumbleOsc = audioContext.createOscillator();
                rumbleOsc.type = 'sawtooth';
                rumbleOsc.frequency.value = baseFreq * 0.15;
                
                // Chaotic modulation
                const rumbleMod = audioContext.createOscillator();
                rumbleMod.frequency.value = 2.3;
                const rumbleModGain = audioContext.createGain();
                rumbleModGain.gain.value = baseFreq * 0.08;
                rumbleMod.connect(rumbleModGain);
                rumbleModGain.connect(rumbleOsc.frequency);
                rumbleMod.start(now);
                rumbleMod.stop(now + duration);
                
                rumbleEnv = audioContext.createGain();
                rumbleEnv.gain.value = 0;
                const rumbleVol = baseVolume * (sound.rumbleVolume || 0.6);
                rumbleEnv.gain.linearRampToValueAtTime(rumbleVol, now + 0.1);
                rumbleEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                rumbleOsc.connect(rumbleEnv);
            }
            
            // BAMBOO WIND CHIMES - hollow resonant tubes (green)
            let bambooNodes = [];
            if (sound.useBamboo && sound.bambooTubes) {
                const bambooVol = sound.bambooVolume || 0.7;
                sound.bambooTubes.forEach((ratio, i) => {
                    const bambooOsc = audioContext.createOscillator();
                    bambooOsc.type = 'triangle';  // Hollow sound
                    bambooOsc.frequency.value = baseFreq * ratio;
                    
                    // Quick strike, long resonance
                    const bambooEnv = audioContext.createGain();
                    bambooEnv.gain.value = 0;
                    const bambooAttackVol = baseVolume * bambooVol / (i * 0.3 + 1);
                    bambooEnv.gain.linearRampToValueAtTime(bambooAttackVol, now + 0.001);
                    bambooEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * sound.bambooDecay);
                    
                    bambooOsc.connect(bambooEnv);
                    bambooNodes.push({ osc: bambooOsc, env: bambooEnv });
                });
            }
            
            // HOLLOW RESONANCE - sub-frequency for bamboo tube effect (green)
            let hollowResonance = null;
            let hollowEnv = null;
            if (sound.useHollowResonance) {
                hollowResonance = audioContext.createOscillator();
                hollowResonance.type = 'sine';
                hollowResonance.frequency.value = baseFreq * sound.resonanceFreq;
                
                hollowEnv = audioContext.createGain();
                hollowEnv.gain.value = 0;
                hollowEnv.gain.linearRampToValueAtTime(baseVolume * 0.4, now + 0.005);
                hollowEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);
                
                hollowResonance.connect(hollowEnv);
            }
            
            // WIND NOISE - air rushing through bamboo (green)
            let windNoise = null;
            let windEnv = null;
            if (sound.useWindNoise) {
                const windBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
                const windData = windBuffer.getChannelData(0);
                for (let i = 0; i < windData.length; i++) {
                    windData[i] = (Math.random() * 2 - 1) * 0.5;
                }
                windNoise = audioContext.createBufferSource();
                windNoise.buffer = windBuffer;
                windNoise.loop = true;
                
                const windFilter = audioContext.createBiquadFilter();
                windFilter.type = 'highpass';
                windFilter.frequency.value = 2000;
                
                windEnv = audioContext.createGain();
                windEnv.gain.value = 0;
                windEnv.gain.linearRampToValueAtTime(baseVolume * sound.windIntensity, now + 0.02);
                windEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.3);
                
                windNoise.connect(windFilter);
                windFilter.connect(windEnv);
            }
            
            // METALLIC SHIMMER - high overtones (green)
            let shimmerNodes = [];
            if (sound.useMetallicShimmer) {
                const numShimmers = sound.shimmerCount || 6;
                for (let i = 0; i < numShimmers; i++) {
                    const shimmerDelay = Math.random() * duration * 0.7;
                    const shimmerOsc = audioContext.createOscillator();
                    shimmerOsc.type = 'sine';
                    shimmerOsc.frequency.value = baseFreq * (5 + Math.random() * 8);
                    
                    const shimmerEnv = audioContext.createGain();
                    shimmerEnv.gain.value = 0;
                    shimmerEnv.gain.setValueAtTime(0, now + shimmerDelay);
                    shimmerEnv.gain.linearRampToValueAtTime(baseVolume * 0.15, now + shimmerDelay + 0.005);
                    shimmerEnv.gain.exponentialRampToValueAtTime(0.001, now + shimmerDelay + 0.2);
                    
                    shimmerOsc.connect(shimmerEnv);
                    shimmerNodes.push({ osc: shimmerOsc, env: shimmerEnv });
                }
            }
            
            // ICE CRACKLE - brittle, fast pops (pink)
            let iceCrackleNodes = [];
            if (sound.useIceCrackle) {
                const numCrackles = sound.iceCrackleCount || 20;
                for (let i = 0; i < numCrackles; i++) {
                    const crackleDelay = Math.random() * duration * 0.95;
                    const crackleOsc = audioContext.createOscillator();
                    crackleOsc.type = 'square';  // Harsh brittle sound
                    crackleOsc.frequency.value = baseFreq * (8 + Math.random() * 12);
                    
                    const crackleEnv = audioContext.createGain();
                    crackleEnv.gain.value = 0;
                    const crackleVol = baseVolume * sound.crackleIntensity * (0.4 + Math.random() * 0.6);
                    crackleEnv.gain.setValueAtTime(0, now + crackleDelay);
                    crackleEnv.gain.linearRampToValueAtTime(crackleVol, now + crackleDelay + sound.crackleSpeed);
                    crackleEnv.gain.exponentialRampToValueAtTime(0.001, now + crackleDelay + sound.crackleSpeed + 0.03);
                    
                    crackleOsc.connect(crackleEnv);
                    iceCrackleNodes.push({ osc: crackleOsc, env: crackleEnv });
                }
            }
            
            // FROZEN RESONANCE - very high pitched layers (pink)
            let frozenResonanceNodes = [];
            if (sound.useFrozenResonance && sound.frozenPitches) {
                sound.frozenPitches.forEach((ratio, i) => {
                    const frozenOsc = audioContext.createOscillator();
                    frozenOsc.type = 'sine';
                    frozenOsc.frequency.value = baseFreq * ratio;
                    
                    const frozenEnv = audioContext.createGain();
                    frozenEnv.gain.value = 0;
                    const frozenVol = baseVolume * 0.3 / (i + 1);
                    frozenEnv.gain.linearRampToValueAtTime(frozenVol, now + 0.001);
                    frozenEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.6);
                    
                    frozenOsc.connect(frozenEnv);
                    frozenResonanceNodes.push({ osc: frozenOsc, env: frozenEnv });
                });
            }
            
            // GLASS SHATTER - scattered high frequency impacts (pink)
            let glassShatterNodes = [];
            if (sound.useGlassShatter) {
                const numShatters = sound.shatterDensity || 10;
                for (let i = 0; i < numShatters; i++) {
                    const shatterDelay = Math.random() * duration * 0.8;
                    const shatterOsc = audioContext.createOscillator();
                    shatterOsc.type = 'sine';
                    shatterOsc.frequency.value = baseFreq * (10 + Math.random() * 15);
                    
                    const shatterEnv = audioContext.createGain();
                    shatterEnv.gain.value = 0;
                    shatterEnv.gain.setValueAtTime(0, now + shatterDelay);
                    shatterEnv.gain.linearRampToValueAtTime(baseVolume * 0.4, now + shatterDelay + 0.001);
                    shatterEnv.gain.exponentialRampToValueAtTime(0.001, now + shatterDelay + 0.05);
                    
                    shatterOsc.connect(shatterEnv);
                    glassShatterNodes.push({ osc: shatterOsc, env: shatterEnv });
                }
            }
            
            // HIGH SHIMMER - ultra-high frequency sparkle (pink)
            let highShimmer = null;
            let highShimmerEnv = null;
            if (sound.useHighShimmer) {
                highShimmer = audioContext.createOscillator();
                highShimmer.type = 'sine';
                highShimmer.frequency.value = baseFreq * sound.shimmerFreq;
                
                highShimmerEnv = audioContext.createGain();
                highShimmerEnv.gain.value = 0;
                highShimmerEnv.gain.linearRampToValueAtTime(baseVolume * 0.25, now + 0.005);
                highShimmerEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.4);
                
                highShimmer.connect(highShimmerEnv);
            }
            
            // METAL GRIND - modulated grinding texture (red)
            let metalGrindOsc = null;
            let metalGrindEnv = null;
            if (sound.useMetalGrind) {
                metalGrindOsc = audioContext.createOscillator();
                metalGrindOsc.type = 'sawtooth';
                metalGrindOsc.frequency.value = baseFreq * 0.5;
                
                // Fast modulation for grinding texture
                const grindMod = audioContext.createOscillator();
                grindMod.frequency.value = sound.grindModulation;
                const grindModGain = audioContext.createGain();
                grindModGain.gain.value = baseFreq * 0.3;
                grindMod.connect(grindModGain);
                grindModGain.connect(metalGrindOsc.frequency);
                grindMod.start(now);
                grindMod.stop(now + duration);
                
                metalGrindEnv = audioContext.createGain();
                metalGrindEnv.gain.value = 0;
                const grindVol = baseVolume * sound.grindIntensity;
                metalGrindEnv.gain.linearRampToValueAtTime(grindVol, now + 0.01);
                metalGrindEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                metalGrindOsc.connect(metalGrindEnv);
            }
            
            // METAL HITS - percussive industrial impacts (red)
            let metalHitNodes = [];
            if (sound.useMetalHits) {
                const numHits = sound.metalHitCount || 12;
                for (let i = 0; i < numHits; i++) {
                    const hitDelay = Math.random() * duration * 0.9;
                    const hitOsc = audioContext.createOscillator();
                    hitOsc.type = 'square';
                    hitOsc.frequency.value = baseFreq * (0.5 + Math.random() * 1.5);
                    
                    const hitEnv = audioContext.createGain();
                    hitEnv.gain.value = 0;
                    const hitVol = baseVolume * sound.metalHitVolume * (0.6 + Math.random() * 0.4);
                    hitEnv.gain.setValueAtTime(0, now + hitDelay);
                    hitEnv.gain.linearRampToValueAtTime(hitVol, now + hitDelay + 0.002);
                    hitEnv.gain.exponentialRampToValueAtTime(0.001, now + hitDelay + 0.08);
                    
                    hitOsc.connect(hitEnv);
                    metalHitNodes.push({ osc: hitOsc, env: hitEnv });
                }
            }
            
            // GRIND NOISE - harsh industrial noise layer (red)
            let grindNoise = null;
            let grindNoiseEnv = null;
            if (sound.useGrindNoise) {
                const grindBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
                const grindData = grindBuffer.getChannelData(0);
                for (let i = 0; i < grindData.length; i++) {
                    grindData[i] = (Math.random() * 2 - 1) * 0.8;
                }
                grindNoise = audioContext.createBufferSource();
                grindNoise.buffer = grindBuffer;
                grindNoise.loop = true;
                
                const grindFilter = audioContext.createBiquadFilter();
                grindFilter.type = 'bandpass';
                grindFilter.frequency.value = 400;
                grindFilter.Q.value = 3;
                
                grindNoiseEnv = audioContext.createGain();
                grindNoiseEnv.gain.value = 0;
                const grindNoiseVol = baseVolume * sound.grindNoiseRatio;
                grindNoiseEnv.gain.linearRampToValueAtTime(grindNoiseVol, now + 0.02);
                grindNoiseEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                grindNoise.connect(grindFilter);
                grindFilter.connect(grindNoiseEnv);
            }
            
            // LOW RUMBLE - deep machinery rumble (red)
            let lowRumble = null;
            let lowRumbleEnv = null;
            if (sound.useLowRumble) {
                lowRumble = audioContext.createOscillator();
                lowRumble.type = 'sawtooth';
                lowRumble.frequency.value = baseFreq * sound.rumbleFreq;
                
                lowRumbleEnv = audioContext.createGain();
                lowRumbleEnv.gain.value = 0;
                lowRumbleEnv.gain.linearRampToValueAtTime(baseVolume * 0.7, now + 0.05);
                lowRumbleEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                lowRumble.connect(lowRumbleEnv);
            }
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(baseVolume, now + sound.attack);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            let noiseNode = null;
            let noiseEnv = null;
            if (sound.useNoise || sound.heavyNoise) {
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = Math.random() * 2 - 1;
                }
                noiseNode = audioContext.createBufferSource();
                noiseNode.buffer = noiseBuffer;
                noiseNode.loop = true;
                
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = sound.heavyNoise ? 'lowpass' : 'bandpass';
                noiseFilter.frequency.value = sound.heavyNoise ? 800 : sound.filterFreq;
                noiseFilter.Q.value = sound.heavyNoise ? 1.5 : 2;
                
                noiseEnv = audioContext.createGain();
                noiseEnv.gain.value = 0;
                const noiseRatio = sound.noiseRatio || 0.4;
                const noiseVol = baseVolume * noiseRatio;
                noiseEnv.gain.linearRampToValueAtTime(noiseVol, now + sound.attack);
                noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                noiseNode.connect(noiseFilter);
                noiseFilter.connect(noiseEnv);
            }
            
            // HIGH SHIMMER layer (pink)
            let shimmerOsc = null;
            let shimmerEnv = null;
            if (sound.highShimmer) {
                shimmerOsc = audioContext.createOscillator();
                shimmerOsc.type = 'sine';
                shimmerOsc.frequency.value = baseFreq * 12;
                
                shimmerEnv = audioContext.createGain();
                shimmerEnv.gain.value = 0;
                shimmerEnv.gain.linearRampToValueAtTime(baseVolume * 0.08, now + 0.02);
                shimmerEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);
                
                shimmerOsc.connect(shimmerEnv);
            }
            
            // HEAVY DISTORTION (brown) - extreme overdrive
            let heavyDistortion = null;
            if (sound.useHeavyDistortion) {
                heavyDistortion = audioContext.createWaveShaper();
                const curve = new Float32Array(512);
                const drive = sound.distortionDrive || 5.0;
                for (let i = 0; i < 512; i++) {
                    const x = (i * 2) / 512 - 1;
                    // Extreme hard clipping with asymmetry for grit
                    const driven = x * drive;
                    if (driven > 1) {
                        curve[i] = 0.95 + Math.random() * 0.05;  // Hard clip with noise
                    } else if (driven < -1) {
                        curve[i] = -0.95 - Math.random() * 0.05;
                    } else {
                        // Aggressive curve before clipping
                        curve[i] = Math.tanh(driven * 1.5) * 0.9;
                    }
                }
                heavyDistortion.curve = curve;
                heavyDistortion.oversample = '2x';
            }
            
            // BIT CRUSHER (brown) - digital degradation
            let bitCrusher = null;
            if (sound.useBitCrusher) {
                bitCrusher = audioContext.createWaveShaper();
                const curve = new Float32Array(512);
                const bits = sound.bitDepth || 4;
                const steps = Math.pow(2, bits);
                for (let i = 0; i < 512; i++) {
                    const x = (i * 2) / 512 - 1;
                    // Quantize to low bit depth
                    const step = Math.round(x * steps) / steps;
                    curve[i] = step;
                }
                bitCrusher.curve = curve;
            }
            
            // WAVESHAPER for distortion (red)
            let waveshaper = null;
            if (sound.useDistortion) {
                waveshaper = audioContext.createWaveShaper();
                const curve = new Float32Array(256);
                const amount = sound.distortionAmount;
                for (let i = 0; i < 256; i++) {
                    const x = (i / 128) - 1;
                    curve[i] = Math.tanh(x * (1 + amount * 10));
                }
                waveshaper.curve = curve;
                waveshaper.oversample = '2x';
            }
            
            const harmonics = [];
            for (let i = 1; i <= sound.harmonics; i++) {
                const harmOsc = audioContext.createOscillator();
                harmOsc.type = 'sine';
                
                const ratio = i + 1 + (Math.random() * 0.5);
                harmOsc.frequency.value = baseFreq * ratio;
                
                if (sound.detune) {
                    harmOsc.detune.value = (Math.random() - 0.5) * sound.detune * 0.5;
                }
                
                const harmEnv = audioContext.createGain();
                harmEnv.gain.value = 0;
                const harmAmp = baseVolume * 0.5 / (i + 1);
                harmEnv.gain.linearRampToValueAtTime(harmAmp, now + sound.attack);
                harmEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                harmOsc.connect(harmEnv);
                harmonics.push({ osc: harmOsc, env: harmEnv });
            }
            
            const filter = audioContext.createBiquadFilter();
            filter.type = sound.filterType;
            filter.frequency.value = sound.filterFreq;
            filter.Q.value = sound.filterQ;
            
            filter.frequency.linearRampToValueAtTime(sound.filterFreq * 1.5, now + duration * 0.3);
            filter.frequency.linearRampToValueAtTime(sound.filterFreq * 0.8, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2));
            
            const dryGain = audioContext.createGain();
            const wetGain = audioContext.createGain();
            dryGain.gain.value = 1 - (sound.reverbMix || 0.5);
            wetGain.gain.value = sound.reverbMix || 0.5;
            
            // Main oscillator routing
            osc.connect(env);
            
            // Route harmonics to filter
            harmonics.forEach(h => h.env.connect(filter));
            
            // Route env through distortion if present (red), otherwise to filter
            if (waveshaper) {
                env.connect(waveshaper);
                waveshaper.connect(filter);
            } else {
                env.connect(filter);
            }
            
            // Add all the texture layers to filter
            if (noiseEnv) noiseEnv.connect(filter);
            if (subBassEnv) subBassEnv.connect(filter);
            if (shimmerEnv) shimmerEnv.connect(filter);
            
            // Crackles (brown) - random organic pops  
            crackleNodes.forEach(node => node.env.connect(filter));
            
            // Rumble (brown) - chaotic low frequency
            if (rumbleEnv) rumbleEnv.connect(filter);
            
            // Bamboo wind chimes (green) - hollow resonant tubes
            bambooNodes.forEach(bamboo => bamboo.env.connect(filter));
            
            // Hollow resonance (green) - sub-frequency
            if (hollowEnv) hollowEnv.connect(filter);
            
            // Wind noise (green) - air rushing through bamboo
            if (windEnv) windEnv.connect(filter);
            
            // Metallic shimmer (green) - high overtones
            shimmerNodes.forEach(shimmer => shimmer.env.connect(filter));
            
            // Ice crackle (pink) - brittle pops
            iceCrackleNodes.forEach(ice => ice.env.connect(filter));
            
            // Frozen resonance (pink) - very high layers
            frozenResonanceNodes.forEach(frozen => frozen.env.connect(filter));
            
            // Glass shatter (pink) - scattered impacts
            glassShatterNodes.forEach(shatter => shatter.env.connect(filter));
            
            // High shimmer (pink) - ultra-high sparkle
            if (highShimmerEnv) highShimmerEnv.connect(filter);
            
            // Metal grind (red) - modulated grinding
            if (metalGrindEnv) metalGrindEnv.connect(filter);
            
            // Metal hits (red) - industrial impacts
            metalHitNodes.forEach(hit => hit.env.connect(filter));
            
            // Grind noise (red) - harsh industrial noise
            if (grindNoiseEnv) grindNoiseEnv.connect(filter);
            
            // Low rumble (red) - deep machinery
            if (lowRumbleEnv) lowRumbleEnv.connect(filter);
            
            // Chain distortion effects for brown
            if (heavyDistortion && bitCrusher) {
                filter.connect(heavyDistortion);
                heavyDistortion.connect(bitCrusher);
                bitCrusher.connect(panner);
            } else if (heavyDistortion) {
                filter.connect(heavyDistortion);
                heavyDistortion.connect(panner);
            } else if (bitCrusher) {
                filter.connect(bitCrusher);
                bitCrusher.connect(panner);
            } else {
                filter.connect(panner);
            }
            
            panner.connect(dryGain);
            panner.connect(wetGain);
            
            dryGain.connect(masterGain);
            wetGain.connect(convolver);
            
            // Start all oscillators
            osc.start(now);
            osc.stop(now + duration);
            
            if (noiseNode) {
                noiseNode.start(now);
                noiseNode.stop(now + duration);
            }
            if (subBass) {
                subBass.start(now);
                subBass.stop(now + duration);
            }
            if (shimmerOsc) {
                shimmerOsc.start(now);
                shimmerOsc.stop(now + duration);
            }
            
            harmonics.forEach(h => {
                h.osc.start(now);
                h.osc.stop(now + duration);
            });
            
            crackleNodes.forEach(node => {
                node.osc.start(now);
                node.osc.stop(now + duration);
            });
            
            if (rumbleOsc) {
                rumbleOsc.start(now);
                rumbleOsc.stop(now + duration);
            }
            
            // GREEN - Bamboo wind chimes
            bambooNodes.forEach(bamboo => {
                bamboo.osc.start(now);
                bamboo.osc.stop(now + duration);
            });
            
            if (hollowResonance) {
                hollowResonance.start(now);
                hollowResonance.stop(now + duration);
            }
            
            if (windNoise) {
                windNoise.start(now);
                windNoise.stop(now + duration);
            }
            
            shimmerNodes.forEach(shimmer => {
                shimmer.osc.start(now);
                shimmer.osc.stop(now + duration);
            });
            
            // PINK - Ice crystals
            iceCrackleNodes.forEach(ice => {
                ice.osc.start(now);
                ice.osc.stop(now + duration);
            });
            
            frozenResonanceNodes.forEach(frozen => {
                frozen.osc.start(now);
                frozen.osc.stop(now + duration);
            });
            
            glassShatterNodes.forEach(shatter => {
                shatter.osc.start(now);
                shatter.osc.stop(now + duration);
            });
            
            if (highShimmer) {
                highShimmer.start(now);
                highShimmer.stop(now + duration);
            }
            
            // RED - Industrial machinery
            if (metalGrindOsc) {
                metalGrindOsc.start(now);
                metalGrindOsc.stop(now + duration);
            }
            
            metalHitNodes.forEach(hit => {
                hit.osc.start(now);
                hit.osc.stop(now + duration);
            });
            
            if (grindNoise) {
                grindNoise.start(now);
                grindNoise.stop(now + duration);
            }
            
            if (lowRumble) {
                lowRumble.start(now);
                lowRumble.stop(now + duration);
            }
        }

        function createMovementSound(velocity, direction, complexity, turbulenceLevel, accel) {
            const now = audioContext.currentTime;
            const baseFreq = quantizePitch(mouseY);
            const velocityMag = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
            
            if (velocityMag < 0.02) return;
            
            const duration = 0.4 + Math.min(velocityMag * 2, 2.0);
            const velocityCurve = Math.pow(velocityMag, 1.5);
            
            const accelBoost = 1 + Math.max(-0.4, Math.min(0.6, accel * 3));
            const baseAmplitude = (0.03 + velocityCurve * 0.15) * (1 + complexity * 0.4);
            const amplitude = baseAmplitude * accelBoost;
            
            const attackTime = accel > 0.1 ? 0.04 : 0.08;
            const horizontalPos = mouseX;
            
            const fundamental = audioContext.createOscillator();
            fundamental.type = 'sine';
            fundamental.frequency.value = baseFreq;
            
            const vibrato = audioContext.createOscillator();
            vibrato.frequency.value = (4 + Math.random() * 2) * (1 + complexity * 0.5);
            const vibratoGain = audioContext.createGain();
            vibratoGain.gain.value = baseFreq * 0.005 * (1 + complexity);
            vibrato.connect(vibratoGain);
            vibratoGain.connect(fundamental.frequency);
            vibrato.start(now);
            vibrato.stop(now + duration);
            
            const fundEnv = audioContext.createGain();
            fundEnv.gain.value = 0;
            
            if (accel > 0.1) {
                fundEnv.gain.linearRampToValueAtTime(amplitude * 0.6, now + attackTime);
                fundEnv.gain.linearRampToValueAtTime(amplitude, now + duration * 0.5);
                fundEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
            } else if (accel < -0.1) {
                fundEnv.gain.linearRampToValueAtTime(amplitude, now + attackTime);
                fundEnv.gain.linearRampToValueAtTime(amplitude * 0.4, now + duration * 0.6);
                fundEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.8);
            } else {
                fundEnv.gain.linearRampToValueAtTime(amplitude, now + attackTime);
                fundEnv.gain.linearRampToValueAtTime(amplitude * 0.8, now + duration * 0.7);
                fundEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
            }
            
            const baseNumHarmonics = Math.floor(2 + complexity * 2);
            const numHarmonics = Math.floor(baseNumHarmonics + horizontalPos * 2);
            const harmonics = [];
            const harmonicRatios = [1.5, 2, 3, 4, 5, 6];
            
            for (let i = 0; i < numHarmonics; i++) {
                const harmOsc = audioContext.createOscillator();
                harmOsc.type = 'sine';
                
                const detuning = (Math.random() - 0.5) * turbulenceLevel * 8;
                harmOsc.frequency.value = baseFreq * harmonicRatios[i] + detuning;
                
                const harmEnv = audioContext.createGain();
                harmEnv.gain.value = 0;
                const harmonicBoost = 1 + (horizontalPos * 0.5);
                const harmAmp = amplitude * (0.2 - i * 0.04) * (1 + complexity * 0.3) * harmonicBoost;
                harmEnv.gain.linearRampToValueAtTime(harmAmp, now + attackTime);
                harmEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                harmOsc.connect(harmEnv);
                harmonics.push({ osc: harmOsc, env: harmEnv });
            }
            
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            noise.loop = true;
            
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = baseFreq * 1.5;
            noiseFilter.Q.value = 2 + velocityCurve * 4 + complexity * 2;
            
            const noiseEnv = audioContext.createGain();
            noiseEnv.gain.value = 0;
            const noiseAmp = amplitude * 0.3 * velocityCurve * (1 + complexity * 0.5 + turbulenceLevel * 1.5);
            noiseEnv.gain.linearRampToValueAtTime(noiseAmp, now + 0.05);
            noiseEnv.gain.linearRampToValueAtTime(noiseAmp * 0.5, now + duration * 0.5);
            noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const mainFilter = audioContext.createBiquadFilter();
            mainFilter.type = 'lowpass';
            const baseFilterFreq = baseFreq * (3 + complexity * 2 + velocityCurve * 2 + turbulenceLevel * 1.5);
            const horizontalFilterBoost = 1 + (horizontalPos * 2);
            mainFilter.frequency.value = baseFilterFreq * horizontalFilterBoost + velocityCurve * 1200;
            mainFilter.Q.value = 0.7 + complexity * 0.5 + turbulenceLevel * 0.8 + (horizontalPos * 0.5);
            
            const dryGain = audioContext.createGain();
            const wetGain = audioContext.createGain();
            dryGain.gain.value = 1 - (horizontalPos * 0.4);
            wetGain.gain.value = 0.3 + (horizontalPos * 0.5);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (mouseX - 0.5) * 1.8));
            
            fundamental.connect(fundEnv);
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseEnv);
            
            fundEnv.connect(mainFilter);
            harmonics.forEach(h => h.env.connect(mainFilter));
            noiseEnv.connect(mainFilter);
            
            mainFilter.connect(panner);
            panner.connect(dryGain);
            panner.connect(wetGain);
            
            dryGain.connect(masterGain);
            wetGain.connect(convolver);
            
            fundamental.start(now);
            fundamental.stop(now + duration);
            harmonics.forEach(h => {
                h.osc.start(now);
                h.osc.stop(now + duration);
            });
            noise.start(now);
            noise.stop(now + duration);
            
            if (velocityMag > 0.3 && Math.random() < 0.2 + complexity * 0.3) {
                createAirPuff(velocityMag * (1 + complexity * 0.5));
            }
        }
        
        function createStopAccent(prevVelocity) {
            const now = audioContext.currentTime;
            const baseFreq = quantizePitch(mouseY);
            const duration = 0.15;
            
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = baseFreq;
            osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, now + duration);
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            const accentVolume = Math.min(prevVelocity * 0.15, 0.2);
            env.gain.linearRampToValueAtTime(accentVolume, now + 0.01);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 2);
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = baseFreq * 2;
            noiseFilter.Q.value = 2;
            
            const noiseEnv = audioContext.createGain();
            noiseEnv.gain.value = 0;
            noiseEnv.gain.linearRampToValueAtTime(accentVolume * 0.3, now + 0.005);
            noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (mouseX - 0.5) * 1.8));
            
            osc.connect(env);
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseEnv);
            
            env.connect(panner);
            noiseEnv.connect(panner);
            panner.connect(masterGain);
            panner.connect(convolver);
            
            osc.start(now);
            osc.stop(now + duration);
            noise.start(now);
        }
        
        function createSplashSound(x, y) {
            const now = audioContext.currentTime;
            const baseFreq = quantizePitch(y);
            const duration = 0.8 + Math.random() * 0.3;
            
            const fundamental = audioContext.createOscillator();
            fundamental.type = 'sine';
            fundamental.frequency.value = baseFreq * 0.5;
            fundamental.frequency.exponentialRampToValueAtTime(baseFreq * 0.4, now + duration);
            
            const fundEnv = audioContext.createGain();
            fundEnv.gain.value = 0;
            fundEnv.gain.linearRampToValueAtTime(0.15, now + 0.02);
            fundEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const sparkle = audioContext.createOscillator();
            sparkle.type = 'sine';
            sparkle.frequency.value = baseFreq * 4 + Math.random() * 500;
            sparkle.frequency.exponentialRampToValueAtTime(baseFreq * 2, now + duration * 0.3);
            
            const sparkleEnv = audioContext.createGain();
            sparkleEnv.gain.value = 0;
            sparkleEnv.gain.linearRampToValueAtTime(0.08, now + 0.01);
            sparkleEnv.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.4);
            
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 1.5);
            }
            
            const splash = audioContext.createBufferSource();
            splash.buffer = noiseBuffer;
            
            const splashFilter = audioContext.createBiquadFilter();
            splashFilter.type = 'bandpass';
            splashFilter.frequency.value = baseFreq * 2;
            splashFilter.Q.value = 3;
            
            const splashEnv = audioContext.createGain();
            splashEnv.gain.value = 0;
            splashEnv.gain.linearRampToValueAtTime(0.12, now + 0.005);
            splashEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (x - 0.5) * 2));
            
            fundamental.connect(fundEnv);
            sparkle.connect(sparkleEnv);
            splash.connect(splashFilter);
            splashFilter.connect(splashEnv);
            
            fundEnv.connect(panner);
            sparkleEnv.connect(panner);
            splashEnv.connect(panner);
            
            panner.connect(masterGain);
            panner.connect(convolver);
            
            fundamental.start(now);
            fundamental.stop(now + duration);
            sparkle.start(now);
            sparkle.stop(now + duration * 0.4);
            splash.start(now);
        }
        
        function createHarmonicRipple(complexity) {
            const now = audioContext.currentTime;
            const baseFreq = quantizePitch(mouseY);
            const duration = 0.3 + complexity * 0.4;
            
            const intervals = [1.25, 1.5, 2];
            const interval = intervals[Math.floor(Math.random() * intervals.length)];
            
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = baseFreq * interval;
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            const amp = 0.02 * complexity;
            env.gain.linearRampToValueAtTime(amp, now + 0.05);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = baseFreq * interval * 2;
            filter.Q.value = 2;
            
            const panner = audioContext.createStereoPanner();
            const panOffset = (Math.random() - 0.5) * 0.6;
            panner.pan.value = Math.max(-1, Math.min(1, (mouseX - 0.5) * 1.8 + panOffset));
            
            osc.connect(filter);
            filter.connect(env);
            env.connect(panner);
            panner.connect(convolver);
            
            osc.start(now);
            osc.stop(now + duration);
        }
        
        function createAirPuff(intensity) {
            const now = audioContext.currentTime;
            const duration = 0.12;
            
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 2000 + Math.random() * 1000;
            filter.Q.value = 1;
            
            const env = audioContext.createGain();
            env.gain.value = 0;
            env.gain.linearRampToValueAtTime(0.03 * intensity, now + 0.01);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, (mouseX - 0.5) * 2));
            
            noise.connect(filter);
            filter.connect(env);
            env.connect(panner);
            panner.connect(convolver);
            
            noise.start(now);
            noise.stop(now + duration);
        }
        
        function updateAudio() {
            if (!audioEnabled) return;
            
            const velocity = Math.sqrt(mouseVelX * mouseVelX + mouseVelY * mouseVelY);
            const now = audioContext.currentTime;
            
            const currentAcceleration = velocity - prevVelocityMag;
            acceleration = acceleration * 0.7 + currentAcceleration * 0.3;
            prevVelocityMag = velocity;
            
            if (velocity > 0.01) {
                recentVelocities.push({ 
                    vx: mouseVelX, 
                    vy: mouseVelY,
                    mag: velocity,
                    time: Date.now() 
                });
                if (recentVelocities.length > MAX_VELOCITIES) {
                    recentVelocities.shift();
                }
            }
            
            if (recentVelocities.length > 3) {
                let avgVx = 0, avgVy = 0, avgMag = 0;
                recentVelocities.forEach(v => {
                    avgVx += v.vx;
                    avgVy += v.vy;
                    avgMag += v.mag;
                });
                avgVx /= recentVelocities.length;
                avgVy /= recentVelocities.length;
                avgMag /= recentVelocities.length;
                
                let dirVariance = 0;
                let magVariance = 0;
                recentVelocities.forEach(v => {
                    const dx = v.vx - avgVx;
                    const dy = v.vy - avgVy;
                    dirVariance += dx * dx + dy * dy;
                    magVariance += Math.pow(v.mag - avgMag, 2);
                });
                dirVariance /= recentVelocities.length;
                magVariance /= recentVelocities.length;
                
                const rawTurbulence = Math.min((dirVariance * 50 + magVariance * 100), 1);
                turbulence = turbulence * 0.9 + rawTurbulence * 0.1;
            } else {
                turbulence *= 0.95;
            }
            
            if (velocity > 0.02) {
                recentPositions.push({ x: mouseX, y: mouseY, time: Date.now() });
                if (recentPositions.length > MAX_POSITIONS) {
                    recentPositions.shift();
                }
            }
            
            const currentTime = Date.now();
            recentPositions = recentPositions.filter(pos => currentTime - pos.time < 2000);
            recentVelocities = recentVelocities.filter(v => currentTime - v.time < 1000);
            
            if (recentPositions.length > 5) {
                let avgX = 0, avgY = 0;
                recentPositions.forEach(pos => {
                    avgX += pos.x;
                    avgY += pos.y;
                });
                avgX /= recentPositions.length;
                avgY /= recentPositions.length;
                
                let spread = 0;
                recentPositions.forEach(pos => {
                    const dx = pos.x - avgX;
                    const dy = pos.y - avgY;
                    spread += Math.sqrt(dx * dx + dy * dy);
                });
                spread /= recentPositions.length;
                
                const targetConcentration = Math.max(0, 1 - spread * 5);
                areaConcentration = areaConcentration * 0.95 + targetConcentration * 0.05;
            } else {
                areaConcentration *= 0.98;
            }
            
            movementMomentum += velocity * 0.8;
            movementMomentum = Math.min(movementMomentum, 3.0);
            movementMomentum *= 0.97;
            
            if (echoGain && echoTone && echoFilter) {
                const echoVolume = movementMomentum * 0.015;
                echoGain.gain.linearRampToValueAtTime(echoVolume, now + 0.5);
                
                const targetPitch = quantizePitch(mouseY);
                echoTone.frequency.linearRampToValueAtTime(targetPitch, now + 0.8);
                
                const filterFreq = 300 + movementMomentum * 400;
                echoFilter.frequency.linearRampToValueAtTime(filterFreq, now + 0.6);
            }
            
            if (rootGain) {
                const rootVolume = Math.min((movementMomentum * 0.008 + areaConcentration * 0.012), 0.025);
                rootGain.gain.linearRampToValueAtTime(rootVolume, now + 0.4);
            }
            
            if (velocity > 0.02 && Date.now() - lastSoundTime > 50) {
                createMovementSound(
                    { x: mouseVelX, y: mouseVelY },
                    { x: mouseVelX / Math.max(0.01, velocity), y: mouseVelY / Math.max(0.01, velocity) },
                    areaConcentration,
                    turbulence,
                    acceleration
                );
                lastSoundTime = Date.now();
                
                if (areaConcentration > 0.5 && Math.random() < areaConcentration) {
                    setTimeout(() => {
                        if (audioEnabled) createHarmonicRipple(areaConcentration);
                    }, 50 + Math.random() * 100);
                }
            }
            
            if (prevVelocityMag > 0.3 && velocity < 0.05 && acceleration < -0.2) {
                createStopAccent(prevVelocityMag);
            }
        }
        
        window.addEventListener('DOMContentLoaded', function() {
            initColorPalette();
            initGlitchPanel();
            initBeatPanel();
            
            const toggleBtn = document.getElementById('toggleAudio');
            const audioPanel = document.getElementById('audioPanel');
            const colorPalette = document.getElementById('colorPalette');
            
            if (toggleBtn) {
                toggleBtn.addEventListener('click', function() {
                    if (!audioEnabled) {
                        initAudio();
                        this.textContent = 'Sound Off';
                        audioPanel.classList.add('expanded');
                        colorPalette.classList.add('visible');
                    } else {
                        audioEnabled = false;
                        if (audioContext) audioContext.close();
                        audioContext = null;
                        this.textContent = 'Sound On';
                        audioPanel.classList.remove('expanded');
                        colorPalette.classList.remove('visible');
                        
                        // Deactivate all glitch effects when audio is off
                        Object.keys(glitchEffects).forEach(key => {
                            if (glitchEffects[key].active) {
                                glitchEffects[key].active = false;
                                const btn = document.querySelector(`[data-glitch="${key}"]`);
                                if (btn) btn.classList.remove('active');
                            }
                        });
                        
                        // Deactivate all beat effects when audio is off
                        Object.keys(beatEffects).forEach(key => {
                            if (beatEffects[key].active) {
                                stopBeat(key);
                                beatEffects[key].active = false;
                                const btn = document.querySelector(`[data-beat="${key}"]`);
                                if (btn) btn.classList.remove('active');
                            }
                        });
                        
                        selectedColorIndex = -1;
                        document.querySelectorAll('.color-swatch').forEach(swatch => {
                            swatch.classList.remove('selected');
                        });
                    }
                });
            }
        });

        function render(time) {
            time *= 0.001;
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            
            // Apply visual glitch effects
            applyVisualGlitches();
            
            const dt = Math.min(1.0 / 60.0, 0.016);
            const deltaX = (mouseX - lastMouseX) * 10.0;
            const deltaY = (mouseY - lastMouseY) * 10.0;
            
            mouseVelX = deltaX;
            mouseVelY = deltaY;
            
            if (pendingClicks.length > 0) {
                pendingClicks.forEach(click => {
                    // Velocity splash
                    gl.useProgram(splatProgram);
                    const posLoc = gl.getAttribLocation(splatProgram, 'position');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(velocity.write);
                    gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), click.x, click.y);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const force = 15.0;
                    gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), 
                        Math.cos(angle) * force, 
                        Math.sin(angle) * force, 
                        0.0
                    );
                    gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.008);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    
                    velocity.swap();
                    
                    // DISABLED: Color ink drop on click (keeping only velocity splash)
                    // Clicks now only create velocity explosions, not color injection
                    // Color injection happens only during mouse movement for more realistic effect
                    /*
                    if (selectedColorIndex >= 0) {
                        const voice = colorVoices[selectedColorIndex];
                        
                        gl.useProgram(colorSplatProgram);
                        const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                        gl.enableVertexAttribArray(colorPosLoc);
                        gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                        
                        bindFramebuffer(colorBuffer.write);
                        gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                        gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), click.x, click.y);
                        
                        gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                            voice.color.r * 1.2, 
                            voice.color.g * 1.2, 
                            voice.color.b * 1.2
                        );
                        gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.003);
                        
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        
                        colorBuffer.swap();
                    }
                    */
                });
                pendingClicks = [];
            }
            
            if (Math.abs(deltaX) > 0.01 || Math.abs(deltaY) > 0.01) {
                // Splat velocity
                gl.useProgram(splatProgram);
                const posLoc = gl.getAttribLocation(splatProgram, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                bindFramebuffer(velocity.write);
                gl.uniform1i(gl.getUniformLocation(splatProgram, 'uTarget'), 0);
                gl.uniform1f(gl.getUniformLocation(splatProgram, 'aspectRatio'), canvas.width / canvas.height);
                gl.uniform2f(gl.getUniformLocation(splatProgram, 'point'), mouseX, mouseY);
                gl.uniform3f(gl.getUniformLocation(splatProgram, 'color'), deltaX, deltaY, 0.0);
                gl.uniform1f(gl.getUniformLocation(splatProgram, 'radius'), 0.002);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                velocity.swap();
                
                // Inject color ink if selected
                if (selectedColorIndex >= 0) {
                    const voice = colorVoices[selectedColorIndex];
                    
                    gl.useProgram(colorSplatProgram);
                    const colorPosLoc = gl.getAttribLocation(colorSplatProgram, 'position');
                    gl.enableVertexAttribArray(colorPosLoc);
                    gl.vertexAttribPointer(colorPosLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    bindFramebuffer(colorBuffer.write);
                    gl.uniform1i(gl.getUniformLocation(colorSplatProgram, 'uTarget'), 0);
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'aspectRatio'), canvas.width / canvas.height);
                    gl.uniform2f(gl.getUniformLocation(colorSplatProgram, 'point'), mouseX, mouseY);
                    
                    const injectionStrength = 0.8;
                    gl.uniform3f(gl.getUniformLocation(colorSplatProgram, 'color'), 
                        voice.color.r * injectionStrength, 
                        voice.color.g * injectionStrength, 
                        voice.color.b * injectionStrength
                    );
                    gl.uniform1f(gl.getUniformLocation(colorSplatProgram, 'radius'), 0.0015);
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    
                    colorBuffer.swap();
                    
                    lastColorIntensity = lastColorIntensity * 0.99 + injectionStrength;
                    
                    if (audioEnabled && Date.now() - lastSoundTime > 80) {
                        triggerColorVoice(selectedColorIndex, mouseX, mouseY, lastColorIntensity);
                        lastSoundTime = Date.now();
                    }
                } else {
                    lastColorIntensity *= 0.99;
                }
                
                updateAudio();
            }
            
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Diffuse color - creates organic watercolor spreading
            gl.useProgram(diffusionProgram);
            const diffPosLoc = gl.getAttribLocation(diffusionProgram, 'position');
            gl.enableVertexAttribArray(diffPosLoc);
            gl.vertexAttribPointer(diffPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            for (let i = 0; i < 3; i++) {
                bindFramebuffer(colorBuffer.write);
                gl.uniform1i(gl.getUniformLocation(diffusionProgram, 'uSource'), 0);
                gl.uniform2f(gl.getUniformLocation(diffusionProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
                gl.uniform1f(gl.getUniformLocation(diffusionProgram, 'diffusionRate'), currentDiffusion * 0.15);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                colorBuffer.swap();
            }
            
            // Advect color with velocity field
            gl.useProgram(advectionProgram);
            const advPosLoc = gl.getAttribLocation(advectionProgram, 'position');
            gl.enableVertexAttribArray(advPosLoc);
            gl.vertexAttribPointer(advPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            bindFramebuffer(colorBuffer.write);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uSource'), 1);
            gl.uniform2f(gl.getUniformLocation(advectionProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dt'), dt);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dissipation'), 0.99);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            colorBuffer.swap();
            
            // Advect velocity
            bindFramebuffer(velocity.write);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(advectionProgram, 'uSource'), 1);
            gl.uniform2f(gl.getUniformLocation(advectionProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dt'), dt);
            gl.uniform1f(gl.getUniformLocation(advectionProgram, 'dissipation'), 0.995);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            velocity.swap();
            
            gl.useProgram(divergenceProgram);
            const divPosLoc = gl.getAttribLocation(divergenceProgram, 'position');
            gl.enableVertexAttribArray(divPosLoc);
            gl.vertexAttribPointer(divPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            bindFramebuffer(divergence);
            gl.uniform1i(gl.getUniformLocation(divergenceProgram, 'uVelocity'), 0);
            gl.uniform2f(gl.getUniformLocation(divergenceProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            bindFramebuffer(pressure.read);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(pressureProgram);
            const pressPosLoc = gl.getAttribLocation(pressureProgram, 'position');
            gl.enableVertexAttribArray(pressPosLoc);
            gl.vertexAttribPointer(pressPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            for (let i = 0; i < 20; i++) {
                bindFramebuffer(pressure.write);
                gl.uniform1i(gl.getUniformLocation(pressureProgram, 'uPressure'), 0);
                gl.uniform1i(gl.getUniformLocation(pressureProgram, 'uDivergence'), 1);
                gl.uniform2f(gl.getUniformLocation(pressureProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, divergence.texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                pressure.swap();
            }
            
            gl.useProgram(gradientSubtractProgram);
            const gradPosLoc = gl.getAttribLocation(gradientSubtractProgram, 'position');
            gl.enableVertexAttribArray(gradPosLoc);
            gl.vertexAttribPointer(gradPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            bindFramebuffer(velocity.write);
            gl.uniform1i(gl.getUniformLocation(gradientSubtractProgram, 'uPressure'), 0);
            gl.uniform1i(gl.getUniformLocation(gradientSubtractProgram, 'uVelocity'), 1);
            gl.uniform2f(gl.getUniformLocation(gradientSubtractProgram, 'texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            velocity.swap();
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(displayProgram);
            
            const dispPosLoc = gl.getAttribLocation(displayProgram, 'position');
            gl.enableVertexAttribArray(dispPosLoc);
            gl.vertexAttribPointer(dispPosLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'uVelocity'), 0);
            gl.uniform1i(gl.getUniformLocation(displayProgram, 'uColor'), 1);
            gl.uniform1f(gl.getUniformLocation(displayProgram, 'time'), time);
            gl.uniform2f(gl.getUniformLocation(displayProgram, 'resolution'), canvas.width, canvas.height);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, colorBuffer.read.texture);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>